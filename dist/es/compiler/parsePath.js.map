{"version":3,"file":"parsePath.js","sources":["../../../src/compiler/parsePath.ts"],"sourcesContent":["import { dotNotationGet } from \"@/utils\";\n/**\n * When selecting text within $richText, we keep information about which text parts are selected\n * within focused fields. If the text part is partially selected, we add information about the selection.\n * This selection has format: \".{textPartCharacterSelectionStartIndex,textPartCharacterSelectionEndIndex}\".\n * We often want to query related to selection text part component config and to do that correctly we need to\n * strip information about selection.\n */\nfunction stripRichTextPartSelection(value: string): string {\n  return value.replace(/\\.\\{\\d+,\\d+\\}$/g, \"\");\n}\nexport { stripRichTextPartSelection };\n\nexport type ParentPathInfo = {\n  templateId: string;\n  fieldName: string;\n  path: string;\n};\n\nexport type PathInfo = {\n  templateId: string;\n  /**\n   * Relative field name. `undefined` when path IS a component.\n   */\n  fieldName?: string;\n  /**\n   * If component is in the collection, then it is its index.\n   */\n  index?: number;\n  parent?: ParentPathInfo;\n};\n\nexport function parsePath(path: string, form: any): PathInfo {\n  const values = form.values;\n  const pathSplit =\n    path === \"\" ? [] : stripRichTextPartSelection(path).split(\".\");\n\n  let pathInfo:\n    | {\n      templateId: string;\n      index?: number;\n      fieldName?: string;\n      parent?: ParentPathInfo;\n    }\n    | undefined = undefined;\n\n  // We're going from current path down the path to find current template and parent template\n  for (let i = pathSplit.length; i >= 0; i--) {\n    const testedPath = pathSplit.slice(0, i).join(\".\");\n    const value = dotNotationGet(values, testedPath);\n\n    if (typeof value === \"object\" && typeof value._component === \"string\") {\n      if (pathInfo === undefined) {\n        pathInfo = {\n          templateId: value._component,\n        };\n\n        // fieldName\n        const fieldPath = pathSplit.slice(i);\n        if (fieldPath.length > 0) {\n          pathInfo.fieldName = fieldPath.join(\".\");\n        }\n\n        const potentialIndex = parseInt(pathSplit[i - 1]);\n        if (!isNaN(potentialIndex)) {\n          pathInfo.index = potentialIndex;\n        }\n      } else {\n        pathInfo.parent = {\n          templateId: value._component,\n          fieldName: pathSplit[i],\n          path: testedPath,\n        };\n        break;\n      }\n    }\n  }\n\n  if (!pathInfo) {\n    throw new Error(`incorrect path: ${path}`);\n  }\n\n  return pathInfo;\n}\n\nexport function findPathOfFirstAncestorOfType(\n  path: string,\n  templateId: string,\n  form: any\n): string {\n  while (true) {\n    const parseResult = parsePath(path, form);\n\n    if (!parseResult.parent) {\n      throw new Error(`couldn't find ancestor of type ${templateId}`);\n    }\n\n    if (parseResult.parent.templateId === templateId) {\n      return parseResult.parent.path;\n    }\n\n    path = parseResult.parent.path;\n  }\n}\n"],"names":["stripRichTextPartSelection","value","replace","parsePath","path","form","values","pathSplit","split","pathInfo","undefined","i","length","testedPath","slice","join","dotNotationGet","_component","templateId","fieldPath","fieldName","potentialIndex","parseInt","isNaN","index","parent","Error","findPathOfFirstAncestorOfType","parseResult"],"mappings":"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"}