{"version":3,"file":"withEasyblocks.js","sources":["../../../../../src/compiler/builtins/$richText/withEasyblocks.ts"],"sourcesContent":["import { deepCompare, keys, uniqueId } from \"@/utils\";\r\nimport {\r\n  Editor,\r\n  NodeEntry,\r\n  Element as SlateElement,\r\n  Node as SlateNode,\r\n  Text,\r\n  Transforms,\r\n} from \"slate\";\r\nimport { RichTextBlockElementType } from \"./$richTextBlockElement/$richTextBlockElement\";\r\n\r\ntype ComparableText = Pick<Text, \"color\" | \"font\">;\r\n\r\n/**\r\n * Tracks which ids were used during current normalization run\r\n */\r\nconst USED_IDS = new Set<string>();\r\n\r\n/**\r\n * Keeps track what was the previous id before generating the unique id. This is needed because Slate rerenders before\r\n * our config updates and it wouldn't know which compiled component to render.\r\n */\r\nexport const NORMALIZED_IDS_TO_IDS = new Map<string, string>();\r\n\r\nfunction withEasyblocks(editor: Editor): Editor {\r\n  const { /*insertText,*/ normalizeNode } = editor;\r\n\r\n  // editor.insertText = (text) => {\r\n  //   // Verify if the current selection is placed at the end of an inline element. If yes, set the selection to start of\r\n  //   // the next element before adding new text. This allows to break out from the inline element if it's placed at the end of line.\r\n  //   if (editor.selection && Range.isCollapsed(editor.selection)) {\r\n  //     const selectedNodeParent = Editor.parent(\r\n  //       editor,\r\n  //       editor.selection.focus.path\r\n  //     );\r\n\r\n  //     if (selectedNodeParent) {\r\n  //       const [parentNode, parentNodePath] = selectedNodeParent;\r\n\r\n  //       if (SlateElement.isElement(parentNode) && editor.isInline(parentNode)) {\r\n  //         const isCursorSetAtTheEnd = Editor.isEnd(\r\n  //           editor,\r\n  //           editor.selection.focus,\r\n  //           parentNodePath\r\n  //         );\r\n\r\n  //         const nodePointAfterInlineElement = Editor.after(\r\n  //           editor,\r\n  //           parentNodePath\r\n  //         );\r\n\r\n  //         if (isCursorSetAtTheEnd && nodePointAfterInlineElement) {\r\n  //           Transforms.setSelection(editor, {\r\n  //             anchor: nodePointAfterInlineElement,\r\n  //             focus: nodePointAfterInlineElement,\r\n  //           });\r\n  //         }\r\n  //       }\r\n  //     }\r\n  //   }\r\n\r\n  //   insertText(text);\r\n  // };\r\n\r\n  editor.normalizeNode = (entry) => {\r\n    // When copying text content from content editable element, Slate wraps pasted content into top most element.\r\n    // We need to unwrap each block element that is nested within another block element.\r\n    if (unwrapBlockElementsNestedWithinBlockElement(editor, entry)) {\r\n      return;\r\n    }\r\n\r\n    // Slate by default compares text elements and merges them, but to compare them it uses strict equality comparison algorithm.\r\n    // We need to compare them using our own algorithm.\r\n    if (mergeVisuallyTheSameOrEmptyTextNodes(editor, entry)) {\r\n      return;\r\n    }\r\n\r\n    // if (normalizeEmptyTextNodesAfterInlineElements(editor, entry)) {\r\n    //   return;\r\n    // }\r\n\r\n    // Rich text and its elements contains collections. Each item of collection should have unique id.\r\n    if (updateNonUniqueIds(editor, entry)) {\r\n      return;\r\n    }\r\n\r\n    // Slate normalizes fields from deepest to lowest. The lowest element is editor element which has empty path.\r\n    if (entry[1].length === 0) {\r\n      USED_IDS.clear();\r\n    }\r\n\r\n    normalizeNode(entry);\r\n  };\r\n\r\n  return editor;\r\n}\r\n\r\nexport { withEasyblocks };\r\n\r\nfunction unwrapBlockElementsNestedWithinBlockElement(\r\n  editor: Editor,\r\n  entry: NodeEntry<SlateNode>\r\n): boolean {\r\n  const [node, path] = entry;\r\n\r\n  if (\r\n    SlateElement.isElement(node) &&\r\n    // This cast is fine since `RichTextBlockElementType` overlaps with type of `node.type`.\r\n    [\"bulleted-list\", \"numbered-list\", \"paragraph\"].includes(\r\n      node.type as RichTextBlockElementType\r\n    )\r\n  ) {\r\n    const nodeParent = SlateNode.parent(editor, path);\r\n\r\n    if (SlateElement.isElement(nodeParent)) {\r\n      if (nodeParent.type === node.type) {\r\n        Transforms.unwrapNodes(editor, { at: path });\r\n        return true;\r\n      }\r\n\r\n      // For now there is only one case where block element can be nested within block element of different type,\r\n      // it can happen while pasting content from one $richText to another. We want to keep the type of pasted content\r\n      // so instead of unwrapping nodes, we lift them one level up.\r\n      if (\r\n        nodeParent.type !== node.type &&\r\n        [\"bulleted-list\", \"numbered-list\", \"paragraph\"].includes(\r\n          nodeParent.type as RichTextBlockElementType\r\n        )\r\n      ) {\r\n        Transforms.liftNodes(editor, { at: path });\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction updateNonUniqueIds(\r\n  editor: Editor,\r\n  entry: NodeEntry<SlateNode>\r\n): boolean {\r\n  const [node, path] = entry;\r\n\r\n  if (Text.isText(node) || SlateElement.isElement(node)) {\r\n    if (USED_IDS.has(node.id)) {\r\n      const newId = uniqueId();\r\n      NORMALIZED_IDS_TO_IDS.set(newId, node.id);\r\n      Transforms.setNodes(\r\n        editor,\r\n        {\r\n          id: newId,\r\n        },\r\n        {\r\n          at: path,\r\n          match: (n) =>\r\n            (Text.isText(n) || SlateElement.isElement(n)) && n.id === node.id,\r\n        }\r\n      );\r\n      return true;\r\n    } else {\r\n      USED_IDS.add(node.id);\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction mergeVisuallyTheSameOrEmptyTextNodes(\r\n  editor: Editor,\r\n  entry: NodeEntry<SlateNode>\r\n): boolean {\r\n  const [node, path] = entry;\r\n\r\n  if (\r\n    SlateElement.isElement(node) &&\r\n    (node.type === \"text-line\" || node.type === \"list-item\")\r\n  ) {\r\n    const textLineChildren = Array.from(SlateNode.children(editor, path));\r\n\r\n    if (textLineChildren.length > 1) {\r\n      for (\r\n        let childIndex = 0;\r\n        childIndex < textLineChildren.length - 1;\r\n        childIndex++\r\n      ) {\r\n        const [currentChildNode, currentChildPath] =\r\n          textLineChildren[childIndex];\r\n        const [nextChildNode, nextChildPath] = textLineChildren[childIndex + 1];\r\n\r\n        if (Text.isText(currentChildNode) && Text.isText(nextChildNode)) {\r\n          if (compareText(currentChildNode, nextChildNode)) {\r\n            Transforms.mergeNodes(editor, {\r\n              at: nextChildPath,\r\n              match: (node) => Text.isText(node),\r\n            });\r\n\r\n            return true;\r\n          }\r\n\r\n          if (\r\n            nextChildNode.text.trim() === \"\" &&\r\n            childIndex + 1 < textLineChildren.length - 1 &&\r\n            currentChildNode.TextWrapper.length === 0\r\n          ) {\r\n            Transforms.mergeNodes(editor, {\r\n              at: nextChildPath,\r\n              match: (node) => Text.isText(node),\r\n            });\r\n\r\n            return true;\r\n          }\r\n\r\n          // `Transforms.mergeNodes` always merges node/nodes at given position into PREVIOUS node.\r\n          // In this case, we want to merge node at current position into next one.\r\n          if (\r\n            currentChildNode.text.trim() === \"\" &&\r\n            nextChildNode !== undefined\r\n          ) {\r\n            Transforms.setNodes(\r\n              editor,\r\n              {\r\n                color: nextChildNode.color,\r\n                font: nextChildNode.font,\r\n              },\r\n              {\r\n                at: currentChildPath,\r\n                match: (node) => Text.isText(node),\r\n              }\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// This function might be useful in the future, but right now it's not needed.\r\n\r\n// Slate normalization rules states that an inline element cannot be first or last child of block element.\r\n// Slate during its own normalization will add empty Text nodes before or/and after inline element.\r\n// Those Text nodes will be missing properties we add during constructing Slate value based on Shopstory config\r\n// thus it will make compilation error because of missing schema prop values.\r\n// function normalizeEmptyTextNodesAfterInlineElements(\r\n//   editor: Editor,\r\n//   entry: NodeEntry<SlateNode>\r\n// ): boolean {\r\n//   const [node, path] = entry;\r\n\r\n//   if (\r\n//     SlateElement.isElement(node) &&\r\n//     (node.type === \"text-line\" || node.type === \"list-item\")\r\n//   ) {\r\n//     for (let index = 0; index < node.children.length; index++) {\r\n//       const childNode = node.children[index];\r\n//       const previousNode = node.children[index - 1];\r\n//       const nextNode = node.children[index + 1];\r\n\r\n//       if (\r\n//         previousNode &&\r\n//         nextNode &&\r\n//         isElementInlineWrapperElement(previousNode) &&\r\n//         isElementInlineWrapperElement(nextNode)\r\n//       ) {\r\n//         if (Text.isText(childNode) && childNode.text === \"\") {\r\n//           Transforms.removeNodes(editor, {\r\n//             at: [...path, index],\r\n//           });\r\n//           return true;\r\n//         }\r\n//       }\r\n\r\n//       if (\r\n//         childNode &&\r\n//         nextNode &&\r\n//         isElementInlineWrapperElement(childNode) &&\r\n//         isElementInlineWrapperElement(nextNode)\r\n//       ) {\r\n//         const nextNodePath = [...path, index + 1];\r\n\r\n//         Transforms.mergeNodes(editor, {\r\n//           at: nextNodePath,\r\n//         });\r\n\r\n//         return true;\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   return false;\r\n// }\r\n\r\nfunction filterNonComparableProperties(obj: Text): ComparableText {\r\n  return keys(obj)\r\n    .filter<keyof ComparableText>((key): key is keyof ComparableText =>\r\n      [\"color\", \"font\", \"TextWrapper\"].includes(key)\r\n    )\r\n    .reduce((filteredObject, currentKey) => {\r\n      filteredObject[currentKey] = obj[currentKey];\r\n      return filteredObject;\r\n    }, {} as ComparableText);\r\n}\r\n\r\nfunction compareText(text1: Text, text2: Text): boolean {\r\n  let areEqual = true;\r\n\r\n  const part1Keys = keys(filterNonComparableProperties(text1));\r\n  const part2Keys = keys(filterNonComparableProperties(text2));\r\n\r\n  if (part1Keys.length !== part2Keys.length) {\r\n    return false;\r\n  }\r\n\r\n  for (let index = 0; index < part1Keys.length; index++) {\r\n    const key = part1Keys[index];\r\n    const part1Value = text1[key];\r\n    const part2Value = text2[key];\r\n    const areValuesEqual = deepCompare(part1Value, part2Value);\r\n\r\n    if (!areValuesEqual) {\r\n      areEqual = false;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return areEqual;\r\n}\r\n"],"names":["USED_IDS","Set","NORMALIZED_IDS_TO_IDS","Map","withEasyblocks","editor","normalizeNode","entry","unwrapBlockElementsNestedWithinBlockElement","mergeVisuallyTheSameOrEmptyTextNodes","updateNonUniqueIds","length","clear","node","path","SlateElement","isElement","includes","type","nodeParent","SlateNode","parent","Transforms","unwrapNodes","at","liftNodes","Text","isText","has","id","newId","uniqueId","set","setNodes","match","n","add","textLineChildren","Array","from","children","childIndex","currentChildNode","currentChildPath","nextChildNode","nextChildPath","compareText","mergeNodes","text","trim","TextWrapper","undefined","color","font","filterNonComparableProperties","obj","keys","filter","key","reduce","filteredObject","currentKey","text1","text2","areEqual","part1Keys","part2Keys","index","part1Value","part2Value","areValuesEqual","deepCompare"],"mappings":"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"}