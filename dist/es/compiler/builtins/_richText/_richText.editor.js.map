{"version":3,"file":"_richText.editor.js","sources":["../../../../../src/compiler/builtins/$richText/$richText.editor.tsx"],"sourcesContent":["\"use client\";\r\nimport { deepClone, deepCompare, dotNotationGet } from \"@/utils\";\r\nimport throttle from \"lodash/throttle\";\r\nimport React, {\r\n  useCallback,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from \"react\";\r\nimport { flushSync } from \"react-dom\";\r\nimport {\r\n  BaseRange,\r\n  Descendant,\r\n  Editor,\r\n  NodeEntry,\r\n  Range,\r\n  Text,\r\n  Transforms,\r\n  createEditor,\r\n} from \"slate\";\r\nimport type {\r\n  RenderElementProps,\r\n  RenderLeafProps,\r\n  RenderPlaceholderProps,\r\n} from \"slate-react\";\r\nimport { Editable, ReactEditor, Slate, withReact } from \"slate-react\";\r\nimport { Box } from \"../../../components/Box/Box\";\r\nimport {\r\n  ComponentBuilder,\r\n  InternalNoCodeComponentProps,\r\n} from \"../../../components/ComponentBuilder/ComponentBuilder\";\r\nimport { RichTextChangedEvent } from \"../../../events\";\r\nimport { getFallbackForLocale } from \"../../../locales\";\r\nimport { responsiveValueFill } from \"../../../responsiveness\";\r\nimport { Devices, ResponsiveValue } from \"../../../types\";\r\nimport { compileBox, getBoxStyles } from \"../../box\";\r\nimport { getDevicesWidths } from \"../../devices\";\r\nimport { duplicateConfig } from \"../../duplicateConfig\";\r\nimport type { RichTextComponentConfig } from \"./$richText\";\r\nimport {\r\n  RICH_TEXT_CONFIG_SYNC_THROTTLE_TIMEOUT,\r\n  RICH_TEXT_FOCUSED_FIELDS_SYNC_THROTTLE_TIMEOUT,\r\n} from \"./$richText.constants\";\r\nimport { Alignment, BlockElement } from \"./$richText.types\";\r\nimport { RichTextBlockElementCompiledComponentConfig } from \"./$richTextBlockElement/$richTextBlockElement\";\r\nimport { RichTextPartComponentConfig } from \"./$richTextPart/$richTextPart\";\r\nimport { RichTextPartClient } from \"./$richTextPart/$richTextPart.client\";\r\nimport { getAbsoluteRichTextPartPath } from \"./getAbsoluteRichTextPartPath\";\r\nimport { updateSelection } from \"./richTextEditorActions\";\r\nimport { convertEditorValueToRichTextElements } from \"./utils/convertEditorValueToRichTextElements\";\r\nimport { convertRichTextElementsToEditorValue } from \"./utils/convertRichTextElementsToEditorValue\";\r\nimport { createTemporaryEditor } from \"./utils/createTemporaryEditor\";\r\nimport { extractElementsFromCompiledComponents } from \"./utils/extractElementsFromCompiledComponents\";\r\nimport { extractTextPartsFromCompiledComponents } from \"./utils/extractTextPartsFromCompiledComponents\";\r\nimport { getEditorSelectionFromFocusedFields } from \"./utils/getEditorSelectionFromFocusedFields\";\r\nimport { getFocusedFieldsFromSlateSelection } from \"./utils/getFocusedFieldsFromSlateSelection\";\r\nimport { getFocusedRichTextPartsConfigPaths } from \"./utils/getFocusedRichTextPartsConfigPaths\";\r\nimport { getRichTextComponentConfigFragment } from \"./utils/getRichTextComponentConfigFragment\";\r\nimport { NORMALIZED_IDS_TO_IDS, withEasyblocks } from \"./withEasyblocks\";\r\n\r\ninterface RichTextProps extends InternalNoCodeComponentProps {\r\n  elements: Array<\r\n    React.ReactElement<{\r\n      compiled: RichTextBlockElementCompiledComponentConfig;\r\n    }>\r\n  >;\r\n  align: ResponsiveValue<Alignment>;\r\n}\r\n\r\nfunction RichTextEditor(props: RichTextProps) {\r\n  const { editorContext } = (window.parent as any).editorWindowAPI;\r\n\r\n  const {\r\n    actions,\r\n    contextParams,\r\n    form,\r\n    focussedField,\r\n    locales,\r\n    setFocussedField,\r\n  } = editorContext;\r\n\r\n  const {\r\n    __easyblocks: {\r\n      path,\r\n      runtime: { resop, stitches, devices },\r\n    },\r\n    align,\r\n  } = props;\r\n\r\n  let richTextConfig: RichTextComponentConfig = dotNotationGet(\r\n    form.values,\r\n    path\r\n  );\r\n\r\n  const [editor] = useState(() => withEasyblocks(withReact(createEditor())));\r\n\r\n  const localizedRichTextElements =\r\n    richTextConfig.elements[contextParams.locale];\r\n\r\n  const fallbackRichTextElements = getFallbackForLocale(\r\n    richTextConfig.elements,\r\n    contextParams.locale,\r\n    locales\r\n  );\r\n\r\n  const richTextElements =\r\n    localizedRichTextElements ?? fallbackRichTextElements;\r\n\r\n  const richTextElementsConfigPath = `${path}.elements.${contextParams.locale}`;\r\n\r\n  const [editorValue, setEditorValue] = useState(() =>\r\n    convertRichTextElementsToEditorValue(richTextElements)\r\n  );\r\n\r\n  // If rich text has no value, we initialize it with default config by updating it during first render\r\n  // This is only possible when we open entry for non main locale without fallback, this is total edge case\r\n  if (richTextElements.length === 0 && !fallbackRichTextElements) {\r\n    // We only want to show rich text for default config within this component, we don't want to update raw content\r\n    // To prevent implicit update of raw content we make a deep copy.\r\n    richTextConfig = deepClone(richTextConfig);\r\n    richTextConfig.elements[contextParams.locale] =\r\n      convertEditorValueToRichTextElements(editorValue);\r\n  }\r\n\r\n  /**\r\n   * Controls the visibility of decoration imitating browser selection of\r\n   * the selected text after the user has blurred the content editable element.\r\n   */\r\n  const [isDecorationActive, setIsDecorationActive] = useState(false);\r\n\r\n  /**\r\n   * Keeps track what caused last change to editor value.\r\n   * This is used in two cases:\r\n   * - text-only changes of editable content shouldn't trigger update of `editor.children` (\"text-input\")\r\n   * - changes from outside of editable content shouldn't trigger writing to editor's history within change callback (\"external\")\r\n   */\r\n  const lastChangeReason = useRef<\"external\" | \"text-input\" | \"paste\">(\r\n    \"text-input\"\r\n  );\r\n\r\n  /**\r\n   * Whether the content editable is enabled or not. We enable it through double click.\r\n   */\r\n  const [isEnabled, setIsEnabled] = useState(false);\r\n  const previousRichTextComponentConfig = useRef<RichTextComponentConfig>();\r\n  const currentSelectionRef = useRef<BaseRange | null>(null);\r\n\r\n  const isConfigChanged = !isConfigEqual(\r\n    previousRichTextComponentConfig.current,\r\n    richTextConfig\r\n  );\r\n\r\n  if (previousRichTextComponentConfig.current && isConfigChanged) {\r\n    if (lastChangeReason.current !== \"paste\") {\r\n      lastChangeReason.current = \"external\";\r\n    }\r\n\r\n    previousRichTextComponentConfig.current = richTextConfig;\r\n    const nextEditorValue =\r\n      convertRichTextElementsToEditorValue(richTextElements);\r\n    // React bails out the render if state setter function is invoked during the render phase.\r\n    // Doing it makes Slate always up-to date with the latest config if it's changed from outside.\r\n    // https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops\r\n    setEditorValue(nextEditorValue);\r\n    editor.children = nextEditorValue;\r\n\r\n    if (isEnabled) {\r\n      const newEditorSelection = getEditorSelectionFromFocusedFields(\r\n        focussedField,\r\n        form\r\n      );\r\n\r\n      if (isDecorationActive) {\r\n        currentSelectionRef.current = newEditorSelection;\r\n      } else {\r\n        // Slate gives us two methods to update its selection:\r\n        // - `setSelection` updates current selection, so `editor.selection` must be not null\r\n        // - `select` sets the selection, so `editor.selection` must be null\r\n        if (newEditorSelection !== null && editor.selection !== null) {\r\n          Transforms.setSelection(editor, newEditorSelection);\r\n        } else if (newEditorSelection !== null && editor.selection === null) {\r\n          Transforms.select(editor, newEditorSelection);\r\n        } else {\r\n          Transforms.deselect(editor);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  useLayoutEffect(() => {\r\n    if (\r\n      isDecorationActive &&\r\n      currentSelectionRef.current !== null &&\r\n      !Range.isCollapsed(currentSelectionRef.current)\r\n    ) {\r\n      splitStringNodes(editor, currentSelectionRef.current);\r\n\r\n      return () => {\r\n        unwrapStringNodesContent(editor);\r\n      };\r\n    }\r\n  }, [editor, isDecorationActive, richTextConfig]);\r\n\r\n  const isRichTextActive = focussedField.some((focusedField: any) =>\r\n    focusedField.startsWith(path)\r\n  );\r\n\r\n  useLayoutEffect(() => {\r\n    // When rich text becomes inactive we want to restore all original [data-slate-string] nodes\r\n    // by removing all span wrappers that we added to show the mocked browser selection.\r\n    if (!isRichTextActive) {\r\n      unwrapStringNodesContent(editor);\r\n    }\r\n  }, [editor, isRichTextActive]);\r\n\r\n  useEffect(() => {\r\n    // We set previous value of rich text only once, then we manually assign it when needed.\r\n    previousRichTextComponentConfig.current = richTextConfig;\r\n  }, []);\r\n\r\n  useEffect(\r\n    // Component is blurred when the user selects other component in editor. This is different from blurring content editable.\r\n    // Content editable can be blurred, but the component can remain active ex. when we select some text within content editable\r\n    // and want to update its color from the sidebar.\r\n    function handleRichTextBlur() {\r\n      if (!isRichTextActive && isEnabled) {\r\n        // editor.children = deepClone(editorValue);\r\n        setIsEnabled(false);\r\n        currentSelectionRef.current = null;\r\n      }\r\n\r\n      if (!editor.selection) {\r\n        return;\r\n      }\r\n\r\n      if (!isRichTextActive) {\r\n        Transforms.deselect(editor);\r\n\r\n        const isSlateValueEmpty = isEditorValueEmpty(\r\n          editor.children as Array<BlockElement>\r\n        );\r\n\r\n        // When value for current locale is empty we want to show value from fallback value instead of placeholder\r\n        // if the fallback value is present.\r\n        if (isSlateValueEmpty && fallbackRichTextElements !== undefined) {\r\n          const nextRichTextElement = deepClone(richTextConfig);\r\n          delete nextRichTextElement.elements[contextParams.locale];\r\n          editor.children = convertRichTextElementsToEditorValue(\r\n            fallbackRichTextElements\r\n          );\r\n          form.change(path, nextRichTextElement);\r\n        }\r\n      }\r\n    },\r\n    [focussedField, isEnabled, isRichTextActive]\r\n  );\r\n\r\n  useEffect(() => {\r\n    // If editor has been refocused and it was blurred earlier we have to disable the decoration to show only browser selection\r\n    if (ReactEditor.isFocused(editor) && isDecorationActive) {\r\n      setIsDecorationActive(false);\r\n    }\r\n  });\r\n\r\n  useEffect(() => {\r\n    function handleRichTextChanged(event: RichTextChangedEvent) {\r\n      if (!editor.selection) {\r\n        return;\r\n      }\r\n\r\n      if (event.data.type === \"@easyblocks-editor/rich-text-changed\") {\r\n        const { payload } = event.data;\r\n        const { editorContext } = (window.parent as any).editorWindowAPI;\r\n\r\n        // Slate is an uncontrolled component and we don't have an easy access to control it.\r\n        // It keeps its state internally and on each change we convert this state to our format.\r\n        // This works great because changing content of editable element is easy, we append or remove things.\r\n        // When we change the color/font of selected text there are many questions:\r\n        // - is the current selection partial or does it span everything?\r\n        // - how to split text chunks when selection is partial?\r\n        // - how to update selection?\r\n        //\r\n        // `Editor.addMark` method automatically will split (or not) text chunks, update selection etc.\r\n        // It will just do all the painful things. After the Slate do its job, we take its current state after the update\r\n        // and convert it to entry and correct focused fields.\r\n        const temporaryEditor = createTemporaryEditor(editor);\r\n\r\n        const updateSelectionResult = updateSelection(\r\n          temporaryEditor,\r\n          payload.prop,\r\n          ...payload.values\r\n        );\r\n\r\n        if (!updateSelectionResult) {\r\n          return;\r\n        }\r\n\r\n        currentSelectionRef.current = temporaryEditor.selection;\r\n\r\n        actions.runChange(() => {\r\n          const newRichTextElement: RichTextComponentConfig = {\r\n            ...richTextConfig,\r\n            elements: {\r\n              ...richTextConfig.elements,\r\n              [editorContext.contextParams.locale]:\r\n                updateSelectionResult.elements,\r\n            },\r\n          };\r\n\r\n          form.change(path, newRichTextElement);\r\n\r\n          const newFocusedFields =\r\n            updateSelectionResult.focusedRichTextParts.map(\r\n              (focusedRichTextPart) =>\r\n                getAbsoluteRichTextPartPath(\r\n                  focusedRichTextPart,\r\n                  path,\r\n                  editorContext.contextParams.locale\r\n                )\r\n            );\r\n\r\n          return newFocusedFields;\r\n        });\r\n      }\r\n    }\r\n\r\n    window.addEventListener(\"message\", handleRichTextChanged);\r\n\r\n    return () => {\r\n      window.removeEventListener(\"message\", handleRichTextChanged);\r\n    };\r\n  }, [richTextConfig, path]);\r\n\r\n  const decorate = createTextSelectionDecorator(editor);\r\n  const Elements = extractElementsFromCompiledComponents(props);\r\n\r\n  function renderElement({\r\n    attributes,\r\n    children,\r\n    element,\r\n  }: RenderElementProps) {\r\n    const Element = Elements.find(\r\n      (Element) =>\r\n        Element._id === element.id ||\r\n        NORMALIZED_IDS_TO_IDS.get(element.id) === Element._id\r\n    );\r\n\r\n    if (!Element) {\r\n      // This can only happen if the current locale has no value and has no fallback\r\n      if (Elements.length === 0) {\r\n        if (element.type === \"list-item\") {\r\n          return (\r\n            <div {...attributes}>\r\n              <div>{children}</div>\r\n            </div>\r\n          );\r\n        }\r\n\r\n        return <div {...attributes}>{children}</div>;\r\n      }\r\n\r\n      throw new Error(\"Missing element\");\r\n    }\r\n\r\n    const compiledStyles = (() => {\r\n      if (Element._component === \"@easyblocks/rich-text-block-element\") {\r\n        if (Element.props.type === \"bulleted-list\") {\r\n          return Element.styled.BulletedList;\r\n        } else if (Element.props.type === \"numbered-list\") {\r\n          return Element.styled.NumberedList;\r\n        } else if (Element.props.type === \"paragraph\") {\r\n          return Element.styled.Paragraph;\r\n        }\r\n      } else if (Element._component === \"@easyblocks/rich-text-line-element\") {\r\n        if (element.type === \"text-line\") {\r\n          return Element.styled.TextLine;\r\n        } else if (element.type === \"list-item\") {\r\n          return Element.styled.ListItem;\r\n        }\r\n      }\r\n    })();\r\n\r\n    if (compiledStyles === undefined) {\r\n      throw new Error(\"Unknown element type\");\r\n    }\r\n\r\n    return (\r\n      <Box\r\n        __compiled={compiledStyles}\r\n        devices={devices}\r\n        stitches={stitches}\r\n        {...attributes}\r\n        // Element annotation for easier debugging\r\n        {...(process.env.NODE_ENV === \"development\" && {\r\n          \"data-shopstory-element-type\": element.type,\r\n          \"data-shopstory-id\": element.id,\r\n        })}\r\n      >\r\n        {element.type === \"list-item\" ? <div>{children}</div> : children}\r\n      </Box>\r\n    );\r\n  }\r\n\r\n  const TextParts = extractTextPartsFromCompiledComponents(props);\r\n\r\n  function renderLeaf({ attributes, children, leaf }: RenderLeafProps) {\r\n    let TextPart = TextParts.find((TextPart) => {\r\n      return TextPart._id === leaf.id;\r\n    });\r\n\r\n    if (!TextPart) {\r\n      TextPart = TextParts.find((TextPart) => {\r\n        return NORMALIZED_IDS_TO_IDS.get(leaf.id) === TextPart._id;\r\n      });\r\n    }\r\n\r\n    if (!TextPart) {\r\n      // This can only happen if the current locale has no value and has no fallback\r\n      if (TextParts.length === 0) {\r\n        return <span {...attributes}>{children}</span>;\r\n      }\r\n\r\n      throw new Error(\"Missing part\");\r\n    }\r\n\r\n    const TextPartComponent = (\r\n      <RichTextPartClient\r\n        value={children}\r\n        Text={\r\n          <Box\r\n            __compiled={TextPart.styled.Text}\r\n            devices={devices}\r\n            stitches={stitches}\r\n            {...attributes}\r\n          />\r\n        }\r\n        TextWrapper={\r\n          TextPart.components.TextWrapper[0] ? (\r\n            <ComponentBuilder\r\n              compiled={TextPart.components.TextWrapper[0]}\r\n              path={path}\r\n              components={editorContext.components}\r\n              passedProps={{\r\n                __isSelected:\r\n                  leaf.isHighlighted && leaf.highlightType === \"textWrapper\",\r\n              }}\r\n            />\r\n          ) : undefined\r\n        }\r\n      />\r\n    );\r\n\r\n    return TextPartComponent;\r\n  }\r\n\r\n  // Setting `display: flex` for element's aligning on `Editable` component makes default styles\r\n  // of placeholder insufficient thus they require to explicitly set `top` and `left`.\r\n  function renderPlaceholder({ attributes, children }: RenderPlaceholderProps) {\r\n    return (\r\n      <span\r\n        {...attributes}\r\n        style={{\r\n          ...attributes.style,\r\n          top: 0,\r\n          left: 0,\r\n        }}\r\n      >\r\n        {children}\r\n      </span>\r\n    );\r\n  }\r\n\r\n  const scheduleConfigSync = useCallback(\r\n    throttle((nextValue: Array<BlockElement>) => {\r\n      setEditorValue(nextValue);\r\n      const nextElements = convertEditorValueToRichTextElements(nextValue);\r\n\r\n      actions.runChange(() => {\r\n        const newRichTextElement: RichTextComponentConfig = {\r\n          ...richTextConfig,\r\n          elements: {\r\n            ...richTextConfig.elements,\r\n            [editorContext.contextParams.locale]: nextElements,\r\n          },\r\n        };\r\n\r\n        form.change(path, newRichTextElement);\r\n        previousRichTextComponentConfig.current = newRichTextElement;\r\n\r\n        if (editor.selection) {\r\n          const nextFocusedFields = getFocusedFieldsFromSlateSelection(\r\n            editor,\r\n            path,\r\n            contextParams.locale\r\n          );\r\n\r\n          return nextFocusedFields;\r\n        }\r\n      });\r\n    }, RICH_TEXT_CONFIG_SYNC_THROTTLE_TIMEOUT),\r\n    [isConfigChanged, editorContext.contextParams.locale]\r\n  );\r\n\r\n  const scheduleFocusedFieldsChange = useCallback(\r\n    // Slate internally throttles the invocation of DOMSelectionChange for performance reasons.\r\n    // We also throttle update of our focused fields state for the same reason.\r\n    // This gives us a good balance between perf and showing updated fields within the sidebar.\r\n    throttle((focusedFields: Parameters<typeof setFocussedField>[0]) => {\r\n      setFocussedField(focusedFields);\r\n    }, RICH_TEXT_FOCUSED_FIELDS_SYNC_THROTTLE_TIMEOUT),\r\n    [setFocussedField]\r\n  );\r\n\r\n  function handleEditableChange(value: Array<Descendant>): void {\r\n    if (!isEnabled) {\r\n      return;\r\n    }\r\n\r\n    // Editor's value can be changed from outside ex. sidebar or history undo/redo. If the last reason for change\r\n    // was \"external\", we skip this change. In case we would like to start typing immediately after undo/redo we\r\n    // set last change reason to `text-input`.\r\n    if (\r\n      lastChangeReason.current === \"external\" ||\r\n      lastChangeReason.current === \"paste\"\r\n    ) {\r\n      lastChangeReason.current = \"text-input\";\r\n      return;\r\n    }\r\n\r\n    const isValueSame = deepCompare(value, editorValue);\r\n\r\n    // Slate runs `onChange` callback on any change, even when the text haven't changed.\r\n    // If value haven't changed, it must be a selection change.\r\n    if (isValueSame) {\r\n      const nextFocusedFields = getFocusedFieldsFromSlateSelection(\r\n        editor,\r\n        path,\r\n        contextParams.locale\r\n      );\r\n\r\n      if (nextFocusedFields) {\r\n        scheduleFocusedFieldsChange(nextFocusedFields);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    lastChangeReason.current = \"text-input\";\r\n    scheduleConfigSync(value as Array<BlockElement>);\r\n  }\r\n\r\n  function handleEditableFocus(): void {\r\n    if (!isEnabled) {\r\n      return;\r\n    }\r\n\r\n    lastChangeReason.current = \"text-input\";\r\n\r\n    // When value for current locale is empty we present the value from fallback.\r\n    // If user focuses editable element, we present the value of fallback unless it's also empty.\r\n    if (!localizedRichTextElements) {\r\n      let nextSlateValue = editor.children;\r\n      let nextRichTextComponentConfig: RichTextComponentConfig;\r\n\r\n      if (fallbackRichTextElements) {\r\n        nextRichTextComponentConfig = richTextConfig;\r\n        const fallbackFirstTextPart =\r\n          fallbackRichTextElements[0].elements[0].elements[0];\r\n\r\n        // Keep only one line element with single empty rich text\r\n        nextRichTextComponentConfig.elements[contextParams.locale] = [\r\n          {\r\n            ...fallbackRichTextElements[0],\r\n            elements: [\r\n              {\r\n                ...fallbackRichTextElements[0].elements[0],\r\n                elements: [\r\n                  {\r\n                    ...fallbackFirstTextPart,\r\n                    value: \"\",\r\n                  } as RichTextPartComponentConfig,\r\n                ],\r\n              },\r\n            ],\r\n          },\r\n        ];\r\n\r\n        nextSlateValue = convertRichTextElementsToEditorValue(\r\n          nextRichTextComponentConfig.elements[contextParams.locale]\r\n        );\r\n\r\n        editor.children = nextSlateValue;\r\n\r\n        Transforms.select(editor, {\r\n          anchor: Editor.start(editor, []),\r\n          focus: Editor.start(editor, []),\r\n        });\r\n\r\n        form.change(path, nextRichTextComponentConfig);\r\n      } else {\r\n        // If current and fallback value is missing we have:\r\n        // - empty Slate value\r\n        // - empty config within component-collection-localised\r\n        // We will build next $richText component config based on current Slate value\r\n        nextRichTextComponentConfig = richTextConfig;\r\n        nextRichTextComponentConfig.elements[contextParams.locale] =\r\n          convertEditorValueToRichTextElements(\r\n            editor.children as Array<BlockElement>\r\n          );\r\n        form.change(path, nextRichTextComponentConfig);\r\n      }\r\n\r\n      previousRichTextComponentConfig.current = nextRichTextComponentConfig;\r\n\r\n      if (editor.selection) {\r\n        const nextFocusedFields = getFocusedRichTextPartsConfigPaths(\r\n          editor\r\n        ).map((richTextPartPath) =>\r\n          getAbsoluteRichTextPartPath(\r\n            richTextPartPath,\r\n            path,\r\n            contextParams.locale\r\n          )\r\n        );\r\n\r\n        setFocussedField(nextFocusedFields);\r\n      }\r\n    }\r\n\r\n    if (isDecorationActive) {\r\n      const root = ReactEditor.findDocumentOrShadowRoot(editor);\r\n      const slateStringElements = root.querySelectorAll(\"[data-slate-string]\");\r\n      slateStringElements.forEach((element) => {\r\n        element.replaceChildren(document.createTextNode(element.textContent!));\r\n      });\r\n    }\r\n  }\r\n\r\n  useEffect(() => {\r\n    function saveLatestSelection() {\r\n      const root = ReactEditor.findDocumentOrShadowRoot(editor);\r\n      const selection = (root as Document).getSelection();\r\n\r\n      if (selection && selection.type === \"Range\") {\r\n        currentSelectionRef.current = ReactEditor.toSlateRange(\r\n          editor,\r\n          selection,\r\n          { exactMatch: false, suppressThrow: true }\r\n        );\r\n      } else {\r\n        currentSelectionRef.current = null;\r\n      }\r\n    }\r\n\r\n    const throttledSaveLatestSelection = throttle(saveLatestSelection, 100);\r\n\r\n    if (isEnabled) {\r\n      window.document.addEventListener(\r\n        \"selectionchange\",\r\n        throttledSaveLatestSelection\r\n      );\r\n\r\n      return () => {\r\n        window.document.removeEventListener(\r\n          \"selectionchange\",\r\n          throttledSaveLatestSelection\r\n        );\r\n      };\r\n    }\r\n  }, [editor, isEnabled]);\r\n\r\n  function handleEditableBlur(): void {\r\n    lastChangeReason.current = \"external\";\r\n    setIsDecorationActive(true);\r\n  }\r\n\r\n  // When copying content from content editable, Slate will copy HTML content of selected nodes\r\n  // and this is not what we want. Instead we set clipboard data to contain selected content\r\n  // in form of rich text editable component config.\r\n  function handleEditableCopy(event: React.ClipboardEvent) {\r\n    const selectedRichTextComponentConfig = getRichTextComponentConfigFragment(\r\n      richTextConfig,\r\n      editorContext\r\n    );\r\n\r\n    event.clipboardData.setData(\r\n      \"text/x-shopstory\",\r\n      JSON.stringify(selectedRichTextComponentConfig)\r\n    );\r\n  }\r\n\r\n  function handleEditablePaste(event: React.ClipboardEvent) {\r\n    const selectedRichTextComponentConfigClipboardData =\r\n      event.clipboardData.getData(\"text/x-shopstory\");\r\n\r\n    if (selectedRichTextComponentConfigClipboardData) {\r\n      const selectedRichTextComponentConfig: RichTextComponentConfig =\r\n        JSON.parse(selectedRichTextComponentConfigClipboardData);\r\n\r\n      // Preventing the default action will also prevent Slate from handling this event on his own.\r\n      event.preventDefault();\r\n\r\n      const nextSlateValue = convertRichTextElementsToEditorValue(\r\n        duplicateConfig(selectedRichTextComponentConfig, editorContext)\r\n          .elements[contextParams.locale]\r\n      );\r\n\r\n      const temporaryEditor = createTemporaryEditor(editor);\r\n      Editor.insertFragment(temporaryEditor, nextSlateValue);\r\n      const nextElements = convertEditorValueToRichTextElements(\r\n        temporaryEditor.children as Array<BlockElement>\r\n      );\r\n\r\n      actions.runChange(() => {\r\n        form.change(richTextElementsConfigPath, nextElements);\r\n\r\n        const nextFocusedFields = getFocusedFieldsFromSlateSelection(\r\n          temporaryEditor,\r\n          path,\r\n          contextParams.locale\r\n        );\r\n\r\n        return nextFocusedFields;\r\n      });\r\n\r\n      lastChangeReason.current = \"paste\";\r\n    } else if (\r\n      // Slate only handles pasting if the clipboardData contains text/plain type.\r\n      // When copying text from the Contentful's rich text editor, the clipboardData contains\r\n      // more than one type, so we have to handle this case manually.\r\n      event.clipboardData.types.length > 1 &&\r\n      event.clipboardData.types.some((type) => type === \"text/plain\")\r\n    ) {\r\n      Editor.insertText(editor, event.clipboardData.getData(\"text/plain\"));\r\n      event.preventDefault();\r\n    }\r\n  }\r\n\r\n  const contentEditableClassName = useMemo(() => {\r\n    const responsiveAlignmentStyles = mapResponsiveAlignmentToStyles(align, {\r\n      devices: editorContext.devices,\r\n      resop,\r\n    });\r\n\r\n    const isFallbackValueShown =\r\n      localizedRichTextElements === undefined &&\r\n      fallbackRichTextElements !== undefined;\r\n\r\n    // When we make a selection of text within editable container and then blur\r\n    // sometimes the browser selection changes and shows incorrectly selected chunks.\r\n    const getStyles = stitches.css({\r\n      display: \"flex\",\r\n      ...responsiveAlignmentStyles,\r\n      cursor: !isEnabled ? \"inherit\" : \"text\",\r\n      \"& *\": {\r\n        pointerEvents: isEnabled ? \"auto\" : \"none\",\r\n        userSelect: isEnabled ? \"auto\" : \"none\",\r\n      },\r\n      \"& *::selection\": {\r\n        backgroundColor: \"#b4d5fe\",\r\n      },\r\n      ...(isDecorationActive && {\r\n        \"& *::selection\": {\r\n          backgroundColor: \"transparent\",\r\n        },\r\n        \"& *[data-easyblocks-rich-text-selection]\": {\r\n          backgroundColor: \"#b4d5fe\",\r\n        },\r\n      }),\r\n      ...(isFallbackValueShown && {\r\n        opacity: 0.5,\r\n      }),\r\n      // Remove any text decoration from slate nodes that are elements. We only need text decoration on text elements.\r\n      \"[data-slate-node]\": {\r\n        textDecoration: \"none\",\r\n      },\r\n    });\r\n\r\n    return getStyles().className;\r\n  }, [\r\n    align,\r\n    isDecorationActive,\r\n    localizedRichTextElements,\r\n    fallbackRichTextElements,\r\n    isEnabled,\r\n  ]);\r\n\r\n  return (\r\n    <Slate editor={editor} value={editorValue} onChange={handleEditableChange}>\r\n      <div>\r\n        {/* this wrapper div prevents from Chrome bug where \"pointer-events: none\" on contenteditable is ignored*/}\r\n        <Editable\r\n          className={contentEditableClassName}\r\n          placeholder=\"Here goes text content\"\r\n          renderElement={renderElement}\r\n          renderLeaf={renderLeaf}\r\n          renderPlaceholder={renderPlaceholder}\r\n          decorate={decorate}\r\n          onFocus={handleEditableFocus}\r\n          onBlur={handleEditableBlur}\r\n          onCopy={handleEditableCopy}\r\n          onPaste={handleEditablePaste}\r\n          onMouseDown={(event) => {\r\n            if (isEnabled) {\r\n              event.stopPropagation();\r\n              return;\r\n            }\r\n\r\n            if (event.detail === 2) {\r\n              event.preventDefault();\r\n\r\n              flushSync(() => {\r\n                setIsEnabled(true);\r\n              });\r\n\r\n              ReactEditor.focus(editor);\r\n\r\n              if (isEditorValueEmpty(editor.children as Array<BlockElement>)) {\r\n                return;\r\n              }\r\n\r\n              const editorSelectionRange = {\r\n                anchor: Editor.start(editor, []),\r\n                focus: Editor.end(editor, []),\r\n              };\r\n\r\n              Transforms.setSelection(editor, editorSelectionRange);\r\n              const editorSelectionDOMRange = ReactEditor.toDOMRange(\r\n                editor,\r\n                editorSelectionRange\r\n              );\r\n\r\n              window\r\n                .getSelection()\r\n                ?.setBaseAndExtent(\r\n                  editorSelectionDOMRange.startContainer,\r\n                  editorSelectionDOMRange.startOffset,\r\n                  editorSelectionDOMRange.endContainer,\r\n                  editorSelectionDOMRange.endOffset\r\n                );\r\n            }\r\n          }}\r\n          readOnly={!isEnabled}\r\n        />\r\n      </div>\r\n    </Slate>\r\n  );\r\n}\r\n\r\nexport { RichTextEditor };\r\nexport type { RichTextProps };\r\n\r\nfunction isEditorValueEmpty(editorValue: Array<BlockElement>) {\r\n  return (\r\n    editorValue.length === 1 &&\r\n    editorValue[0].children.length === 1 &&\r\n    editorValue[0].children[0].children.length === 1 &&\r\n    Text.isText(editorValue[0].children[0].children[0]) &&\r\n    editorValue[0].children[0].children[0].text === \"\"\r\n  );\r\n}\r\n\r\nfunction isConfigEqual(newConfig: any, oldConfig: any) {\r\n  return deepCompare(newConfig, oldConfig);\r\n}\r\n\r\nfunction mapResponsiveAlignmentToStyles(\r\n  align: ResponsiveValue<Alignment>,\r\n  { devices, resop }: { devices: Devices; resop: any }\r\n) {\r\n  function mapAlignmentToFlexAlignment(align: Alignment) {\r\n    if (align === \"center\") {\r\n      return \"center\";\r\n    }\r\n\r\n    if (align === \"right\") {\r\n      return \"flex-end\";\r\n    }\r\n\r\n    return \"flex-start\";\r\n  }\r\n\r\n  const responsiveStyles = resop(\r\n    {\r\n      align: responsiveValueFill(align, devices, getDevicesWidths(devices)),\r\n    },\r\n    (values: any) => {\r\n      return {\r\n        justifyContent: mapAlignmentToFlexAlignment(values.align),\r\n        textAlign: values.align,\r\n      };\r\n    },\r\n    devices\r\n  );\r\n\r\n  const compiledStyles = compileBox(responsiveStyles, devices);\r\n\r\n  return getBoxStyles(compiledStyles, devices);\r\n}\r\n\r\nfunction createTextSelectionDecorator(editor: Editor) {\r\n  return ([node, path]: NodeEntry) => {\r\n    const decorations: Array<Range> = [];\r\n\r\n    if (\r\n      Text.isText(node) &&\r\n      editor.selection !== null &&\r\n      node.TextWrapper.length > 0 &&\r\n      Range.isCollapsed(editor.selection)\r\n    ) {\r\n      const textRange = Editor.range(editor, path);\r\n      const intersection = Range.intersection(editor.selection, textRange);\r\n\r\n      if (intersection !== null) {\r\n        const range = {\r\n          isHighlighted: true,\r\n          highlightType: \"textWrapper\",\r\n          ...textRange,\r\n        };\r\n\r\n        decorations.push(range);\r\n      }\r\n    }\r\n\r\n    return decorations;\r\n  };\r\n}\r\n\r\nfunction splitStringNodes(editor: Editor, selection: BaseRange) {\r\n  const nodes = Editor.nodes(editor, {\r\n    at: selection,\r\n    match: Text.isText,\r\n  });\r\n\r\n  const domNodes = Array.from(nodes).map(([node]) => {\r\n    const domNode = ReactEditor.toDOMNode(editor, node);\r\n\r\n    return domNode;\r\n  });\r\n\r\n  if (domNodes.length === 1) {\r\n    const slateString = domNodes[0].querySelector(\"[data-slate-string]\");\r\n    const textContent = slateString!.textContent!;\r\n    const newChild = document.createDocumentFragment();\r\n\r\n    // Selection made within whole text node\r\n    if (\r\n      textContent.length === selection.focus.offset - selection.anchor.offset ||\r\n      textContent.length === selection.anchor.offset - selection.focus.offset\r\n    ) {\r\n      const selectedTextNode = document.createElement(\"span\");\r\n      selectedTextNode.textContent = textContent;\r\n      selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\r\n      newChild.appendChild(selectedTextNode);\r\n      slateString!.replaceChildren(newChild);\r\n    } else {\r\n      const selectedTextNode = document.createElement(\"span\");\r\n      selectedTextNode.textContent = textContent.slice(\r\n        selection.anchor.offset,\r\n        selection.focus.offset\r\n      );\r\n      selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\r\n      newChild.appendChild(\r\n        document.createTextNode(textContent.slice(0, selection.anchor.offset))\r\n      );\r\n      newChild.appendChild(selectedTextNode);\r\n      newChild.appendChild(\r\n        document.createTextNode(textContent.slice(selection.focus.offset))\r\n      );\r\n      slateString!.replaceChildren(newChild);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  domNodes.forEach((node, index) => {\r\n    const slateString = node.querySelector(\"[data-slate-string]\");\r\n\r\n    if (slateString) {\r\n      const textContent = slateString.textContent!;\r\n      const newChild = document.createDocumentFragment();\r\n\r\n      if (index === 0) {\r\n        newChild.appendChild(\r\n          document.createTextNode(\r\n            slateString.textContent!.slice(0, selection.anchor.offset)\r\n          )\r\n        );\r\n        const selectedTextNode = document.createElement(\"span\");\r\n        selectedTextNode.textContent = textContent.slice(\r\n          selection.anchor.offset\r\n        );\r\n        selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\r\n        newChild.appendChild(selectedTextNode);\r\n\r\n        slateString.replaceChildren(newChild);\r\n      } else if (index === domNodes.length - 1) {\r\n        const selectedTextNode = document.createElement(\"span\");\r\n        selectedTextNode.textContent = textContent.slice(\r\n          0,\r\n          selection.focus.offset\r\n        );\r\n        selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\r\n        newChild.appendChild(selectedTextNode);\r\n        newChild.appendChild(\r\n          document.createTextNode(textContent.slice(selection.focus.offset))\r\n        );\r\n        slateString.replaceChildren(newChild);\r\n      } else {\r\n        const selectedTextNode = document.createElement(\"span\");\r\n        selectedTextNode.textContent = textContent;\r\n        selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\r\n        newChild.appendChild(selectedTextNode);\r\n        slateString.replaceChildren(newChild);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction unwrapStringNodesContent(editor: Editor) {\r\n  const root = ReactEditor.findDocumentOrShadowRoot(editor);\r\n  const slateStringElements = root.querySelectorAll(\"[data-slate-string]\");\r\n  slateStringElements.forEach((element) => {\r\n    element.replaceChildren(document.createTextNode(element.textContent!));\r\n  });\r\n}\r\n"],"names":["editorContext","setFocussedField","__easyblocks","runtime","devices","align","richTextConfig","Transforms","useLayoutEffect","splitStringNodes","useEffect","editor","form","payload","currentSelectionRef","elements","window","element","__compiled","stitches","leaf","TextPart","value","Text","TextWrapper","path","passedProps","children","style","top","left","nextRichTextComponentConfig","focus","slateStringElements","exactMatch","suppressThrow","event","Editor","resop","display","cursor","pointerEvents","userSelect","backgroundColor","opacity","textDecoration","onChange","className","placeholder","renderElement","renderLeaf","renderPlaceholder","decorate","onFocus","onBlur","onCopy","onPaste","flushSync","ReactEditor","readOnly","justifyContent","isHighlighted","highlightType","decorations","at","selectedTextNode","newChild","slateString","domNodes"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuEA;;AACUA;AAAc;;;;;;;AAQpBC;AACF;;AAGEC;;AAEEC;;;AAA4BC;AAAQ;;AAEtCC;AACF;;AAOA;;AAKA;AAMA;;AAKA;;AAIA;AACA;;AAEE;AACA;AACAC;;AAGF;;AAEA;AACF;AACA;AACA;;;AAGE;AACF;AACA;AACA;AACA;AACA;AACE;;AAIA;AACF;AACA;;AAEE;AACA;;AAOA;AACE;;AAEA;;AAGA;AAEA;AACA;AACA;;;AAIA;AACE;AAKA;;AAEA;AACE;AACA;AACA;;AAEEC;;AAEAA;AACF;AACEA;AACF;AACF;AACF;AACF;AAEAC;AACE;AAKEC;AAEA;;;AAGF;;AAGF;AAIAD;AACE;AACA;;;AAGA;AACF;AAEAE;AACE;;;;AAKA;AACA;AACA;;AAEE;AACE;;;AAGF;AAEA;AACE;AACF;;AAGEH;AAEA;;AAIA;AACA;AACA;AACE;AACA;AACAI;AAGAC;AACF;AACF;;AAKJF;AACE;;;AAGA;AACF;AAEAA;;AAEI;AACE;AACF;AAEA;;AACUG;;;AACAb;AAAc;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAOE;AACF;AAEAc;;AAGE;AACE;AACAC;;AAEE;AAEF;;AAGFH;;AAYA;AACF;AACF;AACF;AAEAI;AAEA;AACEA;;AAEJ;AAEA;AACA;;;;;AAKEC;AACkB;AAClB;;AAOE;AACA;AACE;AACE;AAKF;AAEA;AACF;AAEA;AACF;;AAGE;AACE;AACE;;AAEA;;AAEA;AACF;AACF;AACE;AACE;AACF;AACE;AACF;AACF;AACF;;AAGE;AACF;AAEA;AAEIC;AACAd;AACAe;;;;AAMA;AAKN;AAEA;;;;;AAE4CC;AAAsB;AAChE;AACE;AACF;;AAGEC;;AAEA;AACF;;AAGE;AACA;AACE;AACF;AAEA;AACF;AAEA;AAEIC;AACAC;AAEIL;AACAd;AACAe;;AAIJK;;AAIMC;;AAEAC;;AAGA;AAAE;AAGP;AAIL;AACF;;AAEA;AACA;;;;AACyCC;AAAiC;AACxE;AAGIC;;AAEEC;AACAC;AACF;AAAE;AAKR;AAEA;;AAGI;;AAGE;AACE;AACAf;;AAEE;AACF;;AAGFH;;;;AAUE;AACF;AACF;AACF;;AAKA;AACA;AACA;;;AAGA;;;AAME;AACF;;AAEA;AACA;AACA;;;AAME;AACF;AAEA;;AAEA;AACA;AACA;;AAOE;;AAEA;AAEA;AACF;;;AAIF;;;AAII;AACF;;;AAIA;AACA;;AAEE;AACA;AAEA;AACEmB;AACA;;AAGA;;;AAIIhB;;AAGIA;AAEI;AACAO;;;AAKV;;;AASFf;;AAEEyB;AACF;AAEApB;AACF;AACE;AACA;AACA;AACA;AACAmB;AACAA;AAIAnB;AACF;;;;;AAgBA;AACF;AAEA;AACE;AACA;AACAqB;;AAEA;AACF;AACF;AAEAvB;;AAEI;AACA;AAEA;;AAIMwB;AAAmBC;AAAoB;AAE7C;;AAEA;AACF;AAEA;AAEA;;AAME;;;AAMF;AACF;;;;AAKA;;AAEA;AACA;AACA;;AAEE;AAKAC;AAIF;;;AAME;AACE;;AAGA;;AAGA;AAKA;AACAC;AACA;;AAKEzB;;AAQA;AACF;;AAGF;AACE;AACA;AACA;;AAIAyB;;AAEF;AACF;AAEA;AACE;;AAEEC;AACF;;;AAMA;AACA;AACA;AACEC;AACA;AACAC;AACA;AACEC;AACAC;;AAEF;AACEC;;AAEF;AACE;AACEA;;AAEF;AACEA;AACF;AACF;AACA;AACEC;AACF;AACA;AACA;AACEC;AACF;AACF;AAEA;AACF;AAQA;AACSlC;AAAgBW;AAAoBwB;;AAIrCC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEE;;AAEE;AACF;AAEA;;AAGEC;;AAEA;AAEAC;AAEA;AACE;AACF;AAEA;;AAEE1B;;AAGFzB;;;AAcF;;AAEFoD;;AAKV;AAKA;AACE;AAOF;AAEA;AACE;AACF;AAEA;;;AAEarB;AAAwC;;;AAI/C;AACF;;AAGE;AACF;AAEA;AACF;;;;;AAQMsB;;;;AAON;AAEA;AACF;AAEA;AACE;AAAoC;;AAGlC;;;;AAUI;AACEC;AACAC;;;AAIFC;AACF;AACF;AAEA;;AAEJ;AAEA;AACE;AACEC;;AAEF;AAEA;AAAmD;;AAGjD;AACF;AAEA;;AAEE;AACA;;AAEA;AACA;AAIE;;AAEAC;AACAC;AACAC;AACF;AACE;AACAF;AAIAA;;AAIAC;AACAA;AAGAC;AACF;AAEA;AACF;AAEAC;AACE;AAEA;AACE;AACA;;;AAQE;AACAH;AAGAA;AACAC;AAEAC;;AAEA;AACAF;AAIAA;AACAC;AACAA;AAGAC;AACF;AACE;;AAEAF;AACAC;AACAC;AACF;AACF;AACF;AACF;AAEA;AACE;AACA;AACAlC;;AAEA;AACF;;"}