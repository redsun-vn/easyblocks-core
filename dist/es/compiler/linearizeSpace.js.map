{"version":3,"file":"linearizeSpace.js","sources":["../../../src/compiler/linearizeSpace.ts"],"sourcesContent":["import {\r\n  isTrulyResponsiveValue,\r\n  responsiveValueFill,\r\n  responsiveValueForceGet,\r\n  responsiveValueGetDefinedValue,\r\n  responsiveValueGetFirstHigherValue,\r\n  responsiveValueGetFirstLowerValue,\r\n} from \"../responsiveness\";\r\nimport { parseSpacing, spacingToPx } from \"../spacingToPx\";\r\nimport {\r\n  ResponsiveValue,\r\n  Spacing,\r\n  TokenValue,\r\n  TrulyResponsiveValue,\r\n} from \"../types\";\r\nimport { applyAutoUsingResponsiveTokens } from \"./applyAutoUsingResponsiveTokens\";\r\nimport { areWidthsFullyDefined } from \"./areWidthsFullyDefined\";\r\nimport { getDevicesWidths } from \"./devices\";\r\nimport { getDeviceWidthPairs } from \"./getDeviceWidthPairs\";\r\nimport { CompilationContextType } from \"./types\";\r\n\r\nexport function linearizeSpace(\r\n  input: ResponsiveValue<TokenValue<ResponsiveValue<Spacing>>>,\r\n  compilationContext: CompilationContextType,\r\n  widths: TrulyResponsiveValue<number>,\r\n  constant = 0\r\n): ResponsiveValue<TokenValue<ResponsiveValue<Spacing>>> {\r\n  if (!isTrulyResponsiveValue(input)) {\r\n    return input;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Important!\r\n   *\r\n   * Although linearizeSpace takes widths into account (it's obvious) we must still remember about responsive tokens.\r\n   *\r\n   * Responsive tokens will be quite rare (like a container margin or a font size).\r\n   * But still we must remember that responsive tokens are defined relative to SCREEN WIDTH.\r\n   * It means that even if our component has \"width\" that is not a screen width and is very irregular, then responsive tokens relative to screen width takes precedence!\r\n   * So if our component has width 500px on XL and is wider on smaller breakpoint LG (800px), then if responsive token is bigger on XL than LG it will still hold.\r\n   * It makes a total sense. If we broke this rule and somehow applied widths to responsive tokens, then user could see a font that she totally doesn't want for a specific breakpoint.\r\n   * It usually won't hurt at all, because fonts and container margins are responsive by nature. Actually maybe other spacings shouldn't be possible to be responsive at all!\r\n   * That's why first thing below is to fill undefined values with responsive tokens if possible and only then linearize the remaining ones (with widths taken into account).\r\n   *\r\n   */\r\n\r\n  // If responsive value has some token that is responsive, then this token should be applied to all surrounding breakpoints.\r\n  // Responsive token kind of \"overrides auto\".\r\n  // If we want in the future auto for responsive tokens it's not the place for it. Linearizing tokens should happen in creating compilation context.\r\n  const inputAfterResponsiveTokenAuto: TrulyResponsiveValue<\r\n    TokenValue<ResponsiveValue<Spacing>>\r\n  > = applyAutoUsingResponsiveTokens(input, compilationContext);\r\n\r\n  const inputWithScalarNonRefValues: TrulyResponsiveValue<number> = {\r\n    $res: true,\r\n  };\r\n\r\n  compilationContext.devices.forEach((device) => {\r\n    if (inputAfterResponsiveTokenAuto[device.id] === undefined) {\r\n      return;\r\n    }\r\n\r\n    const refValue = responsiveValueGetDefinedValue(\r\n      inputAfterResponsiveTokenAuto,\r\n      device.id,\r\n      compilationContext.devices,\r\n      getDevicesWidths(compilationContext.devices)\r\n    )!;\r\n    if (isTrulyResponsiveValue(refValue.value)) {\r\n      inputWithScalarNonRefValues[device.id] = spacingToPx(\r\n        responsiveValueGetDefinedValue(\r\n          refValue.value,\r\n          device.id,\r\n          compilationContext.devices,\r\n          getDevicesWidths(compilationContext.devices)\r\n        )!,\r\n        device.w\r\n      );\r\n    } else {\r\n      inputWithScalarNonRefValues[device.id] = spacingToPx(\r\n        refValue.value,\r\n        device.w\r\n      );\r\n    }\r\n  });\r\n\r\n  if (!areWidthsFullyDefined(widths, compilationContext.devices)) {\r\n    return responsiveValueFill(\r\n      inputAfterResponsiveTokenAuto,\r\n      compilationContext.devices,\r\n      getDevicesWidths(compilationContext.devices)\r\n    );\r\n  }\r\n\r\n  // Let's run linearize function\r\n  const linearisedCompiledValues = linearizeSpaceWithoutNesting(\r\n    inputWithScalarNonRefValues,\r\n    compilationContext,\r\n    widths,\r\n    constant\r\n  );\r\n\r\n  compilationContext.devices.forEach((device) => {\r\n    if (inputAfterResponsiveTokenAuto[device.id] === undefined) {\r\n      inputAfterResponsiveTokenAuto[device.id] = snapValueToToken(\r\n        responsiveValueForceGet(linearisedCompiledValues, device.id),\r\n        responsiveValueGetFirstLowerValue(\r\n          inputWithScalarNonRefValues,\r\n          device.id,\r\n          compilationContext.devices,\r\n          getDevicesWidths(compilationContext.devices)\r\n        ),\r\n        responsiveValueGetFirstHigherValue(\r\n          inputWithScalarNonRefValues,\r\n          device.id,\r\n          compilationContext.devices,\r\n          getDevicesWidths(compilationContext.devices)\r\n        ),\r\n        compilationContext.theme.space,\r\n        constant\r\n      );\r\n    }\r\n  });\r\n\r\n  return inputAfterResponsiveTokenAuto;\r\n}\r\n\r\nfunction snapValueToToken(\r\n  value: number,\r\n  lowerDefinedValue: number | undefined,\r\n  higherDefinedValue: number | undefined,\r\n  spaces: CompilationContextType[\"theme\"][\"space\"],\r\n  constant: number\r\n) {\r\n  let currentToken: TokenValue<Spacing> | undefined = undefined;\r\n  let minDelta = Number.MAX_VALUE;\r\n\r\n  for (const tokenId in spaces) {\r\n    const tokenValue = spaces[tokenId].value;\r\n\r\n    if (isTrulyResponsiveValue(tokenValue)) {\r\n      // only non-responsive\r\n      continue;\r\n    }\r\n\r\n    const parsedValue = parseSpacing(tokenValue);\r\n\r\n    if (parsedValue.unit === \"vw\") {\r\n      continue;\r\n    }\r\n\r\n    const tokenPxValue = parsedValue.value;\r\n\r\n    // If value smaller than constant then the only possible token is the token equaling the value\r\n    if (value <= constant && tokenPxValue !== value) {\r\n      continue;\r\n    }\r\n\r\n    // token value must be within higher and lower limits\r\n    if (higherDefinedValue !== undefined) {\r\n      if (tokenPxValue > higherDefinedValue) {\r\n        continue;\r\n      }\r\n    }\r\n    if (lowerDefinedValue !== undefined) {\r\n      if (tokenPxValue < lowerDefinedValue) {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (tokenId.split(\".\").length > 1) {\r\n      // only non-prefixed\r\n      continue;\r\n    }\r\n\r\n    // snapped token can never be bigger than our constant\r\n    if (tokenPxValue < constant) {\r\n      continue;\r\n    }\r\n\r\n    const delta = Math.abs(value - tokenPxValue);\r\n    if (\r\n      delta < minDelta ||\r\n      /* in case of equal deltas, let's take bigger token */ (currentToken &&\r\n        delta === minDelta &&\r\n        tokenValue > currentToken.value!)\r\n    ) {\r\n      minDelta = delta;\r\n      currentToken = {\r\n        tokenId,\r\n        value: tokenValue,\r\n        widgetId: \"@easyblocks/space\",\r\n      };\r\n    }\r\n  }\r\n\r\n  if (!currentToken) {\r\n    return {\r\n      value: `${value}px`,\r\n    };\r\n  }\r\n\r\n  return currentToken;\r\n}\r\n\r\nfunction linearizeSpaceWithoutNesting(\r\n  input: ResponsiveValue<number>,\r\n  compilationContext: CompilationContextType,\r\n  widths: TrulyResponsiveValue<number>,\r\n  constant = 0\r\n): ResponsiveValue<number> {\r\n  if (!isTrulyResponsiveValue(input)) {\r\n    return input;\r\n  }\r\n\r\n  // // If only 1 value is defined (2 keys, $res and value), then we return\r\n  // if (Object.keys(input).length === 2) {\r\n  //   return responsiveValueFill(input, compilationContext.devices);\r\n  // }\r\n\r\n  // Empty object returns 0\r\n  if (Object.keys(input).length === 0) {\r\n    console.warn(\r\n      \"linearize Space - empty object input, that shouldn't happen, fallback to 0\"\r\n    );\r\n    return 0;\r\n  }\r\n\r\n  // For now we just use arrays (from previous implementation). Later they're mapped back to object\r\n  const value: (number | null)[] = [];\r\n\r\n  const referencePoints: Array<{ leftIndex?: number; rightIndex?: number }> =\r\n    [];\r\n\r\n  const componentWidths = getDeviceWidthPairs(\r\n    widths,\r\n    compilationContext.devices\r\n  );\r\n\r\n  componentWidths.forEach((componentWidth, index) => {\r\n    const breakpointValue = input[componentWidth.deviceId] as number;\r\n    value[index] = breakpointValue;\r\n\r\n    if (breakpointValue === null || breakpointValue === undefined) {\r\n      value[index] = null; // null padding and normalization\r\n\r\n      let leftIndex: undefined | number;\r\n      let rightIndex: undefined | number;\r\n\r\n      // Let's find closest left index\r\n      for (let i = index - 1; i >= 0; i--) {\r\n        const val = input[componentWidths[i].deviceId];\r\n\r\n        if (val !== undefined) {\r\n          leftIndex = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Let's find closest right index\r\n      for (let i = index + 1; i < componentWidths.length; i++) {\r\n        const val = input[componentWidths[i].deviceId];\r\n\r\n        if (val !== undefined) {\r\n          rightIndex = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (leftIndex === undefined && rightIndex === undefined) {\r\n        throw new Error(\"unreachable\");\r\n      }\r\n\r\n      referencePoints[index] = {\r\n        leftIndex,\r\n        rightIndex,\r\n      };\r\n\r\n      return;\r\n    }\r\n  });\r\n\r\n  referencePoints.forEach((refPoint, index: number) => {\r\n    if (!refPoint) {\r\n      return;\r\n    }\r\n\r\n    const currentX = componentWidths[index].width;\r\n\r\n    // Single point linearity\r\n    if (\r\n      (refPoint.leftIndex !== undefined && refPoint.rightIndex === undefined) ||\r\n      (refPoint.leftIndex === undefined && refPoint.rightIndex !== undefined)\r\n    ) {\r\n      const currentRefPoint = (refPoint.leftIndex ??\r\n        refPoint.rightIndex) as number;\r\n      const refY = value[currentRefPoint]!;\r\n      const refX = componentWidths[currentRefPoint]!.width;\r\n\r\n      const deltaY = refY - constant;\r\n      if (deltaY <= 0) {\r\n        value[index] = refY;\r\n      } else {\r\n        const a = (refY - constant) / refX;\r\n        value[index] = a * currentX + constant;\r\n      }\r\n    } else if (\r\n      refPoint.leftIndex !== undefined &&\r\n      refPoint.rightIndex !== undefined\r\n    ) {\r\n      const p1_x = componentWidths[refPoint.leftIndex!]!.width;\r\n      const p1_y = value[refPoint.leftIndex!]!;\r\n\r\n      // default a, b (enabled when only p1 is defined)\r\n      let a = 0,\r\n        b = p1_y;\r\n\r\n      const p2_x = componentWidths[refPoint.rightIndex!]!.width;\r\n      const p2_y = value[refPoint.rightIndex!]!;\r\n\r\n      const deltaX = p1_x - p2_x;\r\n\r\n      if (deltaX === 0) {\r\n        // if delta 0 then we take lower for left and higher for right\r\n        value[index] = index < refPoint.leftIndex ? p1_y : p2_y;\r\n      } else {\r\n        a = (p1_y - p2_y) / deltaX;\r\n        b = p2_y - a * p2_x;\r\n\r\n        if (a >= 0) {\r\n          // take into account 0 values!!!\r\n          if (p1_y === 0 || p2_y === 0) {\r\n            if (index < refPoint.leftIndex) {\r\n              a = 0;\r\n              b = p1_y;\r\n            } else {\r\n              a = 0;\r\n              b = p2_y;\r\n            }\r\n          }\r\n\r\n          value[index] = currentX * a + b;\r\n        } else {\r\n          // We don't linearize descending functions!\r\n          value[index] = index < refPoint.leftIndex ? p1_y : p2_y;\r\n        }\r\n      }\r\n    } else {\r\n      throw new Error(\"unreachable\");\r\n    }\r\n  });\r\n\r\n  const output: TrulyResponsiveValue<number> = { $res: true };\r\n\r\n  value.forEach((scalarVal, index) => {\r\n    if (scalarVal === undefined || scalarVal === null) {\r\n      return;\r\n    }\r\n\r\n    output[componentWidths[index].deviceId] = scalarVal;\r\n  });\r\n\r\n  return output;\r\n}\r\n"],"names":["linearizeSpace","input","compilationContext","widths","constant","arguments","length","undefined","isTrulyResponsiveValue","inputAfterResponsiveTokenAuto","applyAutoUsingResponsiveTokens","inputWithScalarNonRefValues","$res","devices","forEach","device","id","refValue","responsiveValueGetDefinedValue","getDevicesWidths","value","spacingToPx","w","areWidthsFullyDefined","responsiveValueFill","linearisedCompiledValues","linearizeSpaceWithoutNesting","snapValueToToken","responsiveValueForceGet","responsiveValueGetFirstLowerValue","responsiveValueGetFirstHigherValue","theme","space","lowerDefinedValue","higherDefinedValue","spaces","currentToken","minDelta","Number","MAX_VALUE","tokenId","tokenValue","parsedValue","parseSpacing","unit","tokenPxValue","split","delta","Math","abs","widgetId","Object","keys","console","warn","referencePoints","componentWidths","getDeviceWidthPairs","componentWidth","index","breakpointValue","deviceId","leftIndex","rightIndex","i","val","Error","refPoint","currentX","width","currentRefPoint","refY","refX","deltaY","a","p1_x","p1_y","b","p2_x","p2_y","deltaX","output","scalarVal"],"mappings":";;;;;;;;;;;AAqBO,SAASA,cAAcA,CAC5BC,KAA4D,EAC5DC,kBAA0C,EAC1CC,MAAoC,EAEmB;AAAA,EAAA,IADvDC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,GAAA,CAAA,IAAAD,SAAA,CAAA,CAAA,CAAA,KAAAE,SAAA,GAAAF,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC,CAAA;AAEZ,EAAA,IAAI,CAACG,sBAAsB,CAACP,KAAK,CAAC,EAAE;AAClC,IAAA,OAAOA,KAAK,CAAA;AACd,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACA;AACA;AACA,EAAA,MAAMQ,6BAEL,GAAGC,8BAA8B,CAACT,KAAK,EAAEC,kBAAkB,CAAC,CAAA;AAE7D,EAAA,MAAMS,2BAAyD,GAAG;AAChEC,IAAAA,IAAI,EAAE,IAAA;GACP,CAAA;AAEDV,EAAAA,kBAAkB,CAACW,OAAO,CAACC,OAAO,CAAEC,MAAM,IAAK;IAC7C,IAAIN,6BAA6B,CAACM,MAAM,CAACC,EAAE,CAAC,KAAKT,SAAS,EAAE;AAC1D,MAAA,OAAA;AACF,KAAA;IAEA,MAAMU,QAAQ,GAAGC,8BAA8B,CAC7CT,6BAA6B,EAC7BM,MAAM,CAACC,EAAE,EACTd,kBAAkB,CAACW,OAAO,EAC1BM,gBAAgB,CAACjB,kBAAkB,CAACW,OAAO,CAC7C,CAAE,CAAA;AACF,IAAA,IAAIL,sBAAsB,CAACS,QAAQ,CAACG,KAAK,CAAC,EAAE;AAC1CT,MAAAA,2BAA2B,CAACI,MAAM,CAACC,EAAE,CAAC,GAAGK,WAAW,CAClDH,8BAA8B,CAC5BD,QAAQ,CAACG,KAAK,EACdL,MAAM,CAACC,EAAE,EACTd,kBAAkB,CAACW,OAAO,EAC1BM,gBAAgB,CAACjB,kBAAkB,CAACW,OAAO,CAC7C,CAAC,EACDE,MAAM,CAACO,CACT,CAAC,CAAA;AACH,KAAC,MAAM;AACLX,MAAAA,2BAA2B,CAACI,MAAM,CAACC,EAAE,CAAC,GAAGK,WAAW,CAClDJ,QAAQ,CAACG,KAAK,EACdL,MAAM,CAACO,CACT,CAAC,CAAA;AACH,KAAA;AACF,GAAC,CAAC,CAAA;EAEF,IAAI,CAACC,qBAAqB,CAACpB,MAAM,EAAED,kBAAkB,CAACW,OAAO,CAAC,EAAE;AAC9D,IAAA,OAAOW,mBAAmB,CACxBf,6BAA6B,EAC7BP,kBAAkB,CAACW,OAAO,EAC1BM,gBAAgB,CAACjB,kBAAkB,CAACW,OAAO,CAC7C,CAAC,CAAA;AACH,GAAA;;AAEA;EACA,MAAMY,wBAAwB,GAAGC,4BAA4B,CAC3Df,2BAA2B,EAC3BT,kBAAkB,EAClBC,MAAM,EACNC,QACF,CAAC,CAAA;AAEDF,EAAAA,kBAAkB,CAACW,OAAO,CAACC,OAAO,CAAEC,MAAM,IAAK;IAC7C,IAAIN,6BAA6B,CAACM,MAAM,CAACC,EAAE,CAAC,KAAKT,SAAS,EAAE;AAC1DE,MAAAA,6BAA6B,CAACM,MAAM,CAACC,EAAE,CAAC,GAAGW,gBAAgB,CACzDC,uBAAuB,CAACH,wBAAwB,EAAEV,MAAM,CAACC,EAAE,CAAC,EAC5Da,iCAAiC,CAC/BlB,2BAA2B,EAC3BI,MAAM,CAACC,EAAE,EACTd,kBAAkB,CAACW,OAAO,EAC1BM,gBAAgB,CAACjB,kBAAkB,CAACW,OAAO,CAC7C,CAAC,EACDiB,kCAAkC,CAChCnB,2BAA2B,EAC3BI,MAAM,CAACC,EAAE,EACTd,kBAAkB,CAACW,OAAO,EAC1BM,gBAAgB,CAACjB,kBAAkB,CAACW,OAAO,CAC7C,CAAC,EACDX,kBAAkB,CAAC6B,KAAK,CAACC,KAAK,EAC9B5B,QACF,CAAC,CAAA;AACH,KAAA;AACF,GAAC,CAAC,CAAA;AAEF,EAAA,OAAOK,6BAA6B,CAAA;AACtC,CAAA;AAEA,SAASkB,gBAAgBA,CACvBP,KAAa,EACba,iBAAqC,EACrCC,kBAAsC,EACtCC,MAAgD,EAChD/B,QAAgB,EAChB;EACA,IAAIgC,YAA6C,GAAG7B,SAAS,CAAA;AAC7D,EAAA,IAAI8B,QAAQ,GAAGC,MAAM,CAACC,SAAS,CAAA;AAE/B,EAAA,KAAK,MAAMC,OAAO,IAAIL,MAAM,EAAE;AAC5B,IAAA,MAAMM,UAAU,GAAGN,MAAM,CAACK,OAAO,CAAC,CAACpB,KAAK,CAAA;AAExC,IAAA,IAAIZ,sBAAsB,CAACiC,UAAU,CAAC,EAAE;AACtC;AACA,MAAA,SAAA;AACF,KAAA;AAEA,IAAA,MAAMC,WAAW,GAAGC,YAAY,CAACF,UAAU,CAAC,CAAA;AAE5C,IAAA,IAAIC,WAAW,CAACE,IAAI,KAAK,IAAI,EAAE;AAC7B,MAAA,SAAA;AACF,KAAA;AAEA,IAAA,MAAMC,YAAY,GAAGH,WAAW,CAACtB,KAAK,CAAA;;AAEtC;AACA,IAAA,IAAIA,KAAK,IAAIhB,QAAQ,IAAIyC,YAAY,KAAKzB,KAAK,EAAE;AAC/C,MAAA,SAAA;AACF,KAAA;;AAEA;IACA,IAAIc,kBAAkB,KAAK3B,SAAS,EAAE;MACpC,IAAIsC,YAAY,GAAGX,kBAAkB,EAAE;AACrC,QAAA,SAAA;AACF,OAAA;AACF,KAAA;IACA,IAAID,iBAAiB,KAAK1B,SAAS,EAAE;MACnC,IAAIsC,YAAY,GAAGZ,iBAAiB,EAAE;AACpC,QAAA,SAAA;AACF,OAAA;AACF,KAAA;IAEA,IAAIO,OAAO,CAACM,KAAK,CAAC,GAAG,CAAC,CAACxC,MAAM,GAAG,CAAC,EAAE;AACjC;AACA,MAAA,SAAA;AACF,KAAA;;AAEA;IACA,IAAIuC,YAAY,GAAGzC,QAAQ,EAAE;AAC3B,MAAA,SAAA;AACF,KAAA;IAEA,MAAM2C,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC7B,KAAK,GAAGyB,YAAY,CAAC,CAAA;AAC5C,IAAA,IACEE,KAAK,GAAGV,QAAQ,2DACwCD,YAAY,IAClEW,KAAK,KAAKV,QAAQ,IAClBI,UAAU,GAAGL,YAAY,CAAChB,KAAM,CAAC,EACnC;AACAiB,MAAAA,QAAQ,GAAGU,KAAK,CAAA;AAChBX,MAAAA,YAAY,GAAG;QACbI,OAAO;AACPpB,QAAAA,KAAK,EAAEqB,UAAU;AACjBS,QAAAA,QAAQ,EAAE,mBAAA;OACX,CAAA;AACH,KAAA;AACF,GAAA;EAEA,IAAI,CAACd,YAAY,EAAE;IACjB,OAAO;MACLhB,KAAK,EAAE,GAAGA,KAAK,CAAA,EAAA,CAAA;KAChB,CAAA;AACH,GAAA;AAEA,EAAA,OAAOgB,YAAY,CAAA;AACrB,CAAA;AAEA,SAASV,4BAA4BA,CACnCzB,KAA8B,EAC9BC,kBAA0C,EAC1CC,MAAoC,EAEX;AAAA,EAAA,IADzBC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,GAAA,CAAA,IAAAD,SAAA,CAAA,CAAA,CAAA,KAAAE,SAAA,GAAAF,SAAA,CAAA,CAAA,CAAA,GAAG,CAAC,CAAA;AAEZ,EAAA,IAAI,CAACG,sBAAsB,CAACP,KAAK,CAAC,EAAE;AAClC,IAAA,OAAOA,KAAK,CAAA;AACd,GAAA;;AAEA;AACA;AACA;AACA;;AAEA;EACA,IAAIkD,MAAM,CAACC,IAAI,CAACnD,KAAK,CAAC,CAACK,MAAM,KAAK,CAAC,EAAE;AACnC+C,IAAAA,OAAO,CAACC,IAAI,CACV,4EACF,CAAC,CAAA;AACD,IAAA,OAAO,CAAC,CAAA;AACV,GAAA;;AAEA;EACA,MAAMlC,KAAwB,GAAG,EAAE,CAAA;EAEnC,MAAMmC,eAAmE,GACvE,EAAE,CAAA;EAEJ,MAAMC,eAAe,GAAGC,mBAAmB,CACzCtD,MAAM,EACND,kBAAkB,CAACW,OACrB,CAAC,CAAA;AAED2C,EAAAA,eAAe,CAAC1C,OAAO,CAAC,CAAC4C,cAAc,EAAEC,KAAK,KAAK;AACjD,IAAA,MAAMC,eAAe,GAAG3D,KAAK,CAACyD,cAAc,CAACG,QAAQ,CAAW,CAAA;AAChEzC,IAAAA,KAAK,CAACuC,KAAK,CAAC,GAAGC,eAAe,CAAA;AAE9B,IAAA,IAAIA,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAKrD,SAAS,EAAE;AAC7Da,MAAAA,KAAK,CAACuC,KAAK,CAAC,GAAG,IAAI,CAAC;;AAEpB,MAAA,IAAIG,SAA6B,CAAA;AACjC,MAAA,IAAIC,UAA8B,CAAA;;AAElC;AACA,MAAA,KAAK,IAAIC,CAAC,GAAGL,KAAK,GAAG,CAAC,EAAEK,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACnC,MAAMC,GAAG,GAAGhE,KAAK,CAACuD,eAAe,CAACQ,CAAC,CAAC,CAACH,QAAQ,CAAC,CAAA;QAE9C,IAAII,GAAG,KAAK1D,SAAS,EAAE;AACrBuD,UAAAA,SAAS,GAAGE,CAAC,CAAA;AACb,UAAA,MAAA;AACF,SAAA;AACF,OAAA;;AAEA;AACA,MAAA,KAAK,IAAIA,CAAC,GAAGL,KAAK,GAAG,CAAC,EAAEK,CAAC,GAAGR,eAAe,CAAClD,MAAM,EAAE0D,CAAC,EAAE,EAAE;QACvD,MAAMC,GAAG,GAAGhE,KAAK,CAACuD,eAAe,CAACQ,CAAC,CAAC,CAACH,QAAQ,CAAC,CAAA;QAE9C,IAAII,GAAG,KAAK1D,SAAS,EAAE;AACrBwD,UAAAA,UAAU,GAAGC,CAAC,CAAA;AACd,UAAA,MAAA;AACF,SAAA;AACF,OAAA;AAEA,MAAA,IAAIF,SAAS,KAAKvD,SAAS,IAAIwD,UAAU,KAAKxD,SAAS,EAAE;AACvD,QAAA,MAAM,IAAI2D,KAAK,CAAC,aAAa,CAAC,CAAA;AAChC,OAAA;MAEAX,eAAe,CAACI,KAAK,CAAC,GAAG;QACvBG,SAAS;AACTC,QAAAA,UAAAA;OACD,CAAA;AAED,MAAA,OAAA;AACF,KAAA;AACF,GAAC,CAAC,CAAA;AAEFR,EAAAA,eAAe,CAACzC,OAAO,CAAC,CAACqD,QAAQ,EAAER,KAAa,KAAK;IACnD,IAAI,CAACQ,QAAQ,EAAE;AACb,MAAA,OAAA;AACF,KAAA;AAEA,IAAA,MAAMC,QAAQ,GAAGZ,eAAe,CAACG,KAAK,CAAC,CAACU,KAAK,CAAA;;AAE7C;IACA,IACGF,QAAQ,CAACL,SAAS,KAAKvD,SAAS,IAAI4D,QAAQ,CAACJ,UAAU,KAAKxD,SAAS,IACrE4D,QAAQ,CAACL,SAAS,KAAKvD,SAAS,IAAI4D,QAAQ,CAACJ,UAAU,KAAKxD,SAAU,EACvE;MACA,MAAM+D,eAAe,GAAIH,QAAQ,CAACL,SAAS,IACzCK,QAAQ,CAACJ,UAAqB,CAAA;AAChC,MAAA,MAAMQ,IAAI,GAAGnD,KAAK,CAACkD,eAAe,CAAE,CAAA;AACpC,MAAA,MAAME,IAAI,GAAGhB,eAAe,CAACc,eAAe,CAAC,CAAED,KAAK,CAAA;AAEpD,MAAA,MAAMI,MAAM,GAAGF,IAAI,GAAGnE,QAAQ,CAAA;MAC9B,IAAIqE,MAAM,IAAI,CAAC,EAAE;AACfrD,QAAAA,KAAK,CAACuC,KAAK,CAAC,GAAGY,IAAI,CAAA;AACrB,OAAC,MAAM;AACL,QAAA,MAAMG,CAAC,GAAG,CAACH,IAAI,GAAGnE,QAAQ,IAAIoE,IAAI,CAAA;QAClCpD,KAAK,CAACuC,KAAK,CAAC,GAAGe,CAAC,GAAGN,QAAQ,GAAGhE,QAAQ,CAAA;AACxC,OAAA;AACF,KAAC,MAAM,IACL+D,QAAQ,CAACL,SAAS,KAAKvD,SAAS,IAChC4D,QAAQ,CAACJ,UAAU,KAAKxD,SAAS,EACjC;MACA,MAAMoE,IAAI,GAAGnB,eAAe,CAACW,QAAQ,CAACL,SAAS,CAAE,CAAEO,KAAK,CAAA;AACxD,MAAA,MAAMO,IAAI,GAAGxD,KAAK,CAAC+C,QAAQ,CAACL,SAAS,CAAG,CAAA;;AAExC;MACA,IAAIY,CAAC,GAAG,CAAC;AACPG,QAAAA,CAAC,GAAGD,IAAI,CAAA;MAEV,MAAME,IAAI,GAAGtB,eAAe,CAACW,QAAQ,CAACJ,UAAU,CAAE,CAAEM,KAAK,CAAA;AACzD,MAAA,MAAMU,IAAI,GAAG3D,KAAK,CAAC+C,QAAQ,CAACJ,UAAU,CAAG,CAAA;AAEzC,MAAA,MAAMiB,MAAM,GAAGL,IAAI,GAAGG,IAAI,CAAA;MAE1B,IAAIE,MAAM,KAAK,CAAC,EAAE;AAChB;AACA5D,QAAAA,KAAK,CAACuC,KAAK,CAAC,GAAGA,KAAK,GAAGQ,QAAQ,CAACL,SAAS,GAAGc,IAAI,GAAGG,IAAI,CAAA;AACzD,OAAC,MAAM;AACLL,QAAAA,CAAC,GAAG,CAACE,IAAI,GAAGG,IAAI,IAAIC,MAAM,CAAA;AAC1BH,QAAAA,CAAC,GAAGE,IAAI,GAAGL,CAAC,GAAGI,IAAI,CAAA;QAEnB,IAAIJ,CAAC,IAAI,CAAC,EAAE;AACV;AACA,UAAA,IAAIE,IAAI,KAAK,CAAC,IAAIG,IAAI,KAAK,CAAC,EAAE;AAC5B,YAAA,IAAIpB,KAAK,GAAGQ,QAAQ,CAACL,SAAS,EAAE;AAC9BY,cAAAA,CAAC,GAAG,CAAC,CAAA;AACLG,cAAAA,CAAC,GAAGD,IAAI,CAAA;AACV,aAAC,MAAM;AACLF,cAAAA,CAAC,GAAG,CAAC,CAAA;AACLG,cAAAA,CAAC,GAAGE,IAAI,CAAA;AACV,aAAA;AACF,WAAA;UAEA3D,KAAK,CAACuC,KAAK,CAAC,GAAGS,QAAQ,GAAGM,CAAC,GAAGG,CAAC,CAAA;AACjC,SAAC,MAAM;AACL;AACAzD,UAAAA,KAAK,CAACuC,KAAK,CAAC,GAAGA,KAAK,GAAGQ,QAAQ,CAACL,SAAS,GAAGc,IAAI,GAAGG,IAAI,CAAA;AACzD,SAAA;AACF,OAAA;AACF,KAAC,MAAM;AACL,MAAA,MAAM,IAAIb,KAAK,CAAC,aAAa,CAAC,CAAA;AAChC,KAAA;AACF,GAAC,CAAC,CAAA;AAEF,EAAA,MAAMe,MAAoC,GAAG;AAAErE,IAAAA,IAAI,EAAE,IAAA;GAAM,CAAA;AAE3DQ,EAAAA,KAAK,CAACN,OAAO,CAAC,CAACoE,SAAS,EAAEvB,KAAK,KAAK;AAClC,IAAA,IAAIuB,SAAS,KAAK3E,SAAS,IAAI2E,SAAS,KAAK,IAAI,EAAE;AACjD,MAAA,OAAA;AACF,KAAA;IAEAD,MAAM,CAACzB,eAAe,CAACG,KAAK,CAAC,CAACE,QAAQ,CAAC,GAAGqB,SAAS,CAAA;AACrD,GAAC,CAAC,CAAA;AAEF,EAAA,OAAOD,MAAM,CAAA;AACf;;;;"}