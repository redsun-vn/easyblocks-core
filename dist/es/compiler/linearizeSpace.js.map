{"version":3,"file":"linearizeSpace.js","sources":["../../../src/compiler/linearizeSpace.ts"],"sourcesContent":["import {\n  isTrulyResponsiveValue,\n  responsiveValueFill,\n  responsiveValueForceGet,\n  responsiveValueGetDefinedValue,\n  responsiveValueGetFirstHigherValue,\n  responsiveValueGetFirstLowerValue,\n} from \"../responsiveness\";\nimport { parseSpacing, spacingToPx } from \"../spacingToPx\";\nimport {\n  ResponsiveValue,\n  Spacing,\n  TokenValue,\n  TrulyResponsiveValue,\n} from \"../types\";\nimport { applyAutoUsingResponsiveTokens } from \"./applyAutoUsingResponsiveTokens\";\nimport { areWidthsFullyDefined } from \"./areWidthsFullyDefined\";\nimport { getDevicesWidths } from \"./devices\";\nimport { getDeviceWidthPairs } from \"./getDeviceWidthPairs\";\nimport { CompilationContextType } from \"./types\";\n\nexport function linearizeSpace(\n  input: ResponsiveValue<TokenValue<ResponsiveValue<Spacing>>>,\n  compilationContext: CompilationContextType,\n  widths: TrulyResponsiveValue<number>,\n  constant = 0\n): ResponsiveValue<TokenValue<ResponsiveValue<Spacing>>> {\n  if (!isTrulyResponsiveValue(input)) {\n    return input;\n  }\n\n  /**\n   *\n   * Important!\n   *\n   * Although linearizeSpace takes widths into account (it's obvious) we must still remember about responsive tokens.\n   *\n   * Responsive tokens will be quite rare (like a container margin or a font size).\n   * But still we must remember that responsive tokens are defined relative to SCREEN WIDTH.\n   * It means that even if our component has \"width\" that is not a screen width and is very irregular, then responsive tokens relative to screen width takes precedence!\n   * So if our component has width 500px on XL and is wider on smaller breakpoint LG (800px), then if responsive token is bigger on XL than LG it will still hold.\n   * It makes a total sense. If we broke this rule and somehow applied widths to responsive tokens, then user could see a font that she totally doesn't want for a specific breakpoint.\n   * It usually won't hurt at all, because fonts and container margins are responsive by nature. Actually maybe other spacings shouldn't be possible to be responsive at all!\n   * That's why first thing below is to fill undefined values with responsive tokens if possible and only then linearize the remaining ones (with widths taken into account).\n   *\n   */\n\n  // If responsive value has some token that is responsive, then this token should be applied to all surrounding breakpoints.\n  // Responsive token kind of \"overrides auto\".\n  // If we want in the future auto for responsive tokens it's not the place for it. Linearizing tokens should happen in creating compilation context.\n  const inputAfterResponsiveTokenAuto: TrulyResponsiveValue<\n    TokenValue<ResponsiveValue<Spacing>>\n  > = applyAutoUsingResponsiveTokens(input, compilationContext);\n\n  const inputWithScalarNonRefValues: TrulyResponsiveValue<number> = {\n    $res: true,\n  };\n\n  compilationContext.devices.forEach((device) => {\n    if (inputAfterResponsiveTokenAuto[device.id] === undefined) {\n      return;\n    }\n\n    const refValue = responsiveValueGetDefinedValue(\n      inputAfterResponsiveTokenAuto,\n      device.id,\n      compilationContext.devices,\n      getDevicesWidths(compilationContext.devices)\n    )!;\n    if (isTrulyResponsiveValue(refValue.value)) {\n      inputWithScalarNonRefValues[device.id] = spacingToPx(\n        responsiveValueGetDefinedValue(\n          refValue.value,\n          device.id,\n          compilationContext.devices,\n          getDevicesWidths(compilationContext.devices)\n        )!,\n        device.w\n      );\n    } else {\n      inputWithScalarNonRefValues[device.id] = spacingToPx(\n        refValue.value,\n        device.w\n      );\n    }\n  });\n\n  if (!areWidthsFullyDefined(widths, compilationContext.devices)) {\n    return responsiveValueFill(\n      inputAfterResponsiveTokenAuto,\n      compilationContext.devices,\n      getDevicesWidths(compilationContext.devices)\n    );\n  }\n\n  // Let's run linearize function\n  const linearisedCompiledValues = linearizeSpaceWithoutNesting(\n    inputWithScalarNonRefValues,\n    compilationContext,\n    widths,\n    constant\n  );\n\n  compilationContext.devices.forEach((device) => {\n    if (inputAfterResponsiveTokenAuto[device.id] === undefined) {\n      inputAfterResponsiveTokenAuto[device.id] = snapValueToToken(\n        responsiveValueForceGet(linearisedCompiledValues, device.id),\n        responsiveValueGetFirstLowerValue(\n          inputWithScalarNonRefValues,\n          device.id,\n          compilationContext.devices,\n          getDevicesWidths(compilationContext.devices)\n        ),\n        responsiveValueGetFirstHigherValue(\n          inputWithScalarNonRefValues,\n          device.id,\n          compilationContext.devices,\n          getDevicesWidths(compilationContext.devices)\n        ),\n        compilationContext.theme.space,\n        constant\n      );\n    }\n  });\n\n  return inputAfterResponsiveTokenAuto;\n}\n\nfunction snapValueToToken(\n  value: number,\n  lowerDefinedValue: number | undefined,\n  higherDefinedValue: number | undefined,\n  spaces: CompilationContextType[\"theme\"][\"space\"],\n  constant: number\n) {\n  let currentToken: TokenValue<Spacing> | undefined = undefined;\n  let minDelta = Number.MAX_VALUE;\n\n  for (const tokenId in spaces) {\n    const tokenValue = spaces[tokenId].value;\n\n    if (isTrulyResponsiveValue(tokenValue)) {\n      // only non-responsive\n      continue;\n    }\n\n    const parsedValue = parseSpacing(tokenValue);\n\n    if (parsedValue.unit === \"vw\") {\n      continue;\n    }\n\n    const tokenPxValue = parsedValue.value;\n\n    // If value smaller than constant then the only possible token is the token equaling the value\n    if (value <= constant && tokenPxValue !== value) {\n      continue;\n    }\n\n    // token value must be within higher and lower limits\n    if (higherDefinedValue !== undefined) {\n      if (tokenPxValue > higherDefinedValue) {\n        continue;\n      }\n    }\n    if (lowerDefinedValue !== undefined) {\n      if (tokenPxValue < lowerDefinedValue) {\n        continue;\n      }\n    }\n\n    if (tokenId.split(\".\").length > 1) {\n      // only non-prefixed\n      continue;\n    }\n\n    // snapped token can never be bigger than our constant\n    if (tokenPxValue < constant) {\n      continue;\n    }\n\n    const delta = Math.abs(value - tokenPxValue);\n    if (\n      delta < minDelta ||\n      /* in case of equal deltas, let's take bigger token */ (currentToken &&\n        delta === minDelta &&\n        tokenValue > currentToken.value!)\n    ) {\n      minDelta = delta;\n      currentToken = {\n        tokenId,\n        value: tokenValue,\n        widgetId: \"@easyblocks/space\",\n      };\n    }\n  }\n\n  if (!currentToken) {\n    return {\n      value: `${value}px`,\n    };\n  }\n\n  return currentToken;\n}\n\nfunction linearizeSpaceWithoutNesting(\n  input: ResponsiveValue<number>,\n  compilationContext: CompilationContextType,\n  widths: TrulyResponsiveValue<number>,\n  constant = 0\n): ResponsiveValue<number> {\n  if (!isTrulyResponsiveValue(input)) {\n    return input;\n  }\n\n  // // If only 1 value is defined (2 keys, $res and value), then we return\n  // if (Object.keys(input).length === 2) {\n  //   return responsiveValueFill(input, compilationContext.devices);\n  // }\n\n  // Empty object returns 0\n  if (Object.keys(input).length === 0) {\n    console.warn(\n      \"linearize Space - empty object input, that shouldn't happen, fallback to 0\"\n    );\n    return 0;\n  }\n\n  // For now we just use arrays (from previous implementation). Later they're mapped back to object\n  const value: (number | null)[] = [];\n\n  const referencePoints: Array<{ leftIndex?: number; rightIndex?: number }> =\n    [];\n\n  const componentWidths = getDeviceWidthPairs(\n    widths,\n    compilationContext.devices\n  );\n\n  componentWidths.forEach((componentWidth, index) => {\n    const breakpointValue = input[componentWidth.deviceId] as number;\n    value[index] = breakpointValue;\n\n    if (breakpointValue === null || breakpointValue === undefined) {\n      value[index] = null; // null padding and normalization\n\n      let leftIndex: undefined | number;\n      let rightIndex: undefined | number;\n\n      // Let's find closest left index\n      for (let i = index - 1; i >= 0; i--) {\n        const val = input[componentWidths[i].deviceId];\n\n        if (val !== undefined) {\n          leftIndex = i;\n          break;\n        }\n      }\n\n      // Let's find closest right index\n      for (let i = index + 1; i < componentWidths.length; i++) {\n        const val = input[componentWidths[i].deviceId];\n\n        if (val !== undefined) {\n          rightIndex = i;\n          break;\n        }\n      }\n\n      if (leftIndex === undefined && rightIndex === undefined) {\n        throw new Error(\"unreachable\");\n      }\n\n      referencePoints[index] = {\n        leftIndex,\n        rightIndex,\n      };\n\n      return;\n    }\n  });\n\n  referencePoints.forEach((refPoint, index: number) => {\n    if (!refPoint) {\n      return;\n    }\n\n    const currentX = componentWidths[index].width;\n\n    // Single point linearity\n    if (\n      (refPoint.leftIndex !== undefined && refPoint.rightIndex === undefined) ||\n      (refPoint.leftIndex === undefined && refPoint.rightIndex !== undefined)\n    ) {\n      const currentRefPoint = (refPoint.leftIndex ??\n        refPoint.rightIndex) as number;\n      const refY = value[currentRefPoint]!;\n      const refX = componentWidths[currentRefPoint]!.width;\n\n      const deltaY = refY - constant;\n      if (deltaY <= 0) {\n        value[index] = refY;\n      } else {\n        const a = (refY - constant) / refX;\n        value[index] = a * currentX + constant;\n      }\n    } else if (\n      refPoint.leftIndex !== undefined &&\n      refPoint.rightIndex !== undefined\n    ) {\n      const p1_x = componentWidths[refPoint.leftIndex!]!.width;\n      const p1_y = value[refPoint.leftIndex!]!;\n\n      // default a, b (enabled when only p1 is defined)\n      let a = 0,\n        b = p1_y;\n\n      const p2_x = componentWidths[refPoint.rightIndex!]!.width;\n      const p2_y = value[refPoint.rightIndex!]!;\n\n      const deltaX = p1_x - p2_x;\n\n      if (deltaX === 0) {\n        // if delta 0 then we take lower for left and higher for right\n        value[index] = index < refPoint.leftIndex ? p1_y : p2_y;\n      } else {\n        a = (p1_y - p2_y) / deltaX;\n        b = p2_y - a * p2_x;\n\n        if (a >= 0) {\n          // take into account 0 values!!!\n          if (p1_y === 0 || p2_y === 0) {\n            if (index < refPoint.leftIndex) {\n              a = 0;\n              b = p1_y;\n            } else {\n              a = 0;\n              b = p2_y;\n            }\n          }\n\n          value[index] = currentX * a + b;\n        } else {\n          // We don't linearize descending functions!\n          value[index] = index < refPoint.leftIndex ? p1_y : p2_y;\n        }\n      }\n    } else {\n      throw new Error(\"unreachable\");\n    }\n  });\n\n  const output: TrulyResponsiveValue<number> = { $res: true };\n\n  value.forEach((scalarVal, index) => {\n    if (scalarVal === undefined || scalarVal === null) {\n      return;\n    }\n\n    output[componentWidths[index].deviceId] = scalarVal;\n  });\n\n  return output;\n}\n"],"names":["linearizeSpace","input","compilationContext","widths","constant","arguments","length","undefined","isTrulyResponsiveValue","inputAfterResponsiveTokenAuto","applyAutoUsingResponsiveTokens","inputWithScalarNonRefValues","$res","devices","forEach","device","id","refValue","responsiveValueGetDefinedValue","getDevicesWidths","value","spacingToPx","w","areWidthsFullyDefined","responsiveValueFill","linearisedCompiledValues","linearizeSpaceWithoutNesting","snapValueToToken","responsiveValueForceGet","responsiveValueGetFirstLowerValue","responsiveValueGetFirstHigherValue","theme","space","lowerDefinedValue","higherDefinedValue","spaces","currentToken","minDelta","Number","MAX_VALUE","tokenId","tokenValue","parsedValue","parseSpacing","unit","tokenPxValue","split","delta","Math","abs","widgetId","Object","keys","console","warn","referencePoints","componentWidths","getDeviceWidthPairs","componentWidth","index","breakpointValue","deviceId","leftIndex","rightIndex","i","val","Error","refPoint","currentX","width","currentRefPoint","refY","refX","deltaY","a","p1_x","p1_y","b","p2_x","p2_y","deltaX","output","scalarVal"],"mappings":"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"}