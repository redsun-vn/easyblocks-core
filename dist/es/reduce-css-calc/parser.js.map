{"version":3,"file":"parser.js","sources":["../../../src/reduce-css-calc/parser.js"],"sourcesContent":["/* parser generated by jison 0.6.1-215 */\r\n\r\n/*\r\n * Returns a Parser object of the following structure:\r\n *\r\n *  Parser: {\r\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\r\n *               the real \"shared state\" `yy` passed around to\r\n *               the rule actions, etc. is a derivative/copy of this one,\r\n *               not a direct reference!\r\n *  }\r\n *\r\n *  Parser.prototype: {\r\n *    yy: {},\r\n *    EOF: 1,\r\n *    TERROR: 2,\r\n *\r\n *    trace: function(errorMessage, ...),\r\n *\r\n *    JisonParserError: function(msg, hash),\r\n *\r\n *    quoteName: function(name),\r\n *               Helper function which can be overridden by user code later on: put suitable\r\n *               quotes around literal IDs in a description string.\r\n *\r\n *    originalQuoteName: function(name),\r\n *               The basic quoteName handler provided by JISON.\r\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\r\n *               at the end of the `parse()`.\r\n *\r\n *    describeSymbol: function(symbol),\r\n *               Return a more-or-less human-readable description of the given symbol, when\r\n *               available, or the symbol itself, serving as its own 'description' for lack\r\n *               of something better to serve up.\r\n *\r\n *               Return NULL when the symbol is unknown to the parser.\r\n *\r\n *    symbols_: {associative list: name ==> number},\r\n *    terminals_: {associative list: number ==> name},\r\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\r\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\r\n *    productions_: [...],\r\n *\r\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\r\n *\r\n *               The function parameters and `this` have the following value/meaning:\r\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\r\n *                             to store/reference the rule value `$$` and location info `@$`.\r\n *\r\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\r\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\r\n *                 data from one reduce action through to the next within a single parse run, then you\r\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\r\n *\r\n *                 `this.yy` is a direct reference to the `yy` shared state object.\r\n *\r\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\r\n *                 object at `parse()` start and are therefore available to the action code via the\r\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\r\n *                 the %parse-param` list.\r\n *\r\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\r\n *                             to match this rule. This is *not* the look-ahead token, but the last token\r\n *                             that's actually part of this rule.\r\n *\r\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\r\n *                 the current look-ahead token.\r\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\r\n *\r\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\r\n *\r\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\r\n *\r\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\r\n *\r\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\r\n *                               of an empty object when no suitable location info can be provided.\r\n *\r\n *               - `yystate` : the current parser state number, used internally for dispatching and\r\n *                               executing the action code chunk matching the rule currently being reduced.\r\n *\r\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\r\n *\r\n *                 This one comes in handy when you are going to do advanced things to the parser\r\n *                 stacks, all of which are accessible from your action code (see the next entries below).\r\n *\r\n *                 Also note that you can access this and other stack index values using the new double-hash\r\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\r\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\r\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\r\n *                 to investigate the parse state stack in your action code, which would, for example,\r\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\r\n *                 to the work described here:\r\n *\r\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\r\n *                   In Journées Francophones des Languages Applicatifs.\r\n *\r\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\r\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\r\n *\r\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\r\n *\r\n *                 This one comes in handy when you are going to do advanced things to the parser\r\n *                 stacks, all of which are accessible from your action code (see the next entries below).\r\n *\r\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\r\n *                             constructs.\r\n *\r\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\r\n *                             the `@1` etc. constructs.\r\n *\r\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\r\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\r\n *                             action code did not provide a suitable location info object when such a\r\n *                             slot was filled!\r\n *\r\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\r\n *                             `#1` etc. constructs.\r\n *\r\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\r\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\r\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\r\n *\r\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\r\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\r\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\r\n *                 *reduced*.\r\n *\r\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\r\n *                             *states* such as the one in `yystate`, which are used to represent\r\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\r\n *                             what can I say? If you access this one, you're clearly doing wicked things\r\n *\r\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\r\n *                             grammar definition file.\r\n *\r\n *    table: [...],\r\n *               State transition table\r\n *               ----------------------\r\n *\r\n *               index levels are:\r\n *               - `state`  --> hash table\r\n *               - `symbol` --> action (number or array)\r\n *\r\n *                 If the `action` is an array, these are the elements' meaning:\r\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\r\n *                 - index [1]: GOTO `state`\r\n *\r\n *                 If the `action` is a number, it is the GOTO `state`\r\n *\r\n *    defaultActions: {...},\r\n *\r\n *    parseError: function(str, hash, ExceptionClass),\r\n *    yyError: function(str, ...),\r\n *    yyRecovering: function(),\r\n *    yyErrOk: function(),\r\n *    yyClearIn: function(),\r\n *\r\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\r\n *               See it's use in this parser kernel in many places; example usage:\r\n *\r\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\r\n *                                     parser.collect_expected_token_set(state), true);\r\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\r\n *\r\n *    originalParseError: function(str, hash, ExceptionClass),\r\n *               The basic `parseError` handler provided by JISON.\r\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\r\n *               at the end of the `parse()`.\r\n *\r\n *    options: { ... parser %options ... },\r\n *\r\n *    parse: function(input[, args...]),\r\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\r\n *               the root action, in which case the parser is acting as a *matcher*).\r\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\r\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\r\n *\r\n *               WARNING:\r\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\r\n *               any attributes already added to `yy` by the jison run-time;\r\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\r\n *               from silently accepting this confusing and potentially hazardous situation!\r\n *\r\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\r\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\r\n *               object and any collision with those will be reported by the lexer via a thrown exception.\r\n *\r\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\r\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\r\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\r\n *               the internal parser gets properly garbage collected under these particular circumstances.\r\n *\r\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\r\n *\r\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\r\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\r\n *               backwards.\r\n *\r\n *               For more info see the documentation comment further below, immediately above this function's\r\n *               implementation.\r\n *\r\n *    lexer: {\r\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\r\n *                             received via a call to the `.setInput(input, yy)` lexer API.\r\n *        EOF: 1,\r\n *        ERROR: 2,\r\n *        JisonLexerError: function(msg, hash),\r\n *        parseError: function(str, hash, ExceptionClass),\r\n *        setInput: function(input, [yy]),\r\n *        input: function(),\r\n *        unput: function(str),\r\n *        more: function(),\r\n *        reject: function(),\r\n *        less: function(n),\r\n *        pastInput: function(n),\r\n *        upcomingInput: function(n),\r\n *        showPosition: function(),\r\n *        test_match: function(regex_match_array, rule_index, ...),\r\n *        next: function(...),\r\n *        lex: function(...),\r\n *        begin: function(condition),\r\n *        pushState: function(condition),\r\n *        popState: function(),\r\n *        topState: function(),\r\n *        _currentRules: function(),\r\n *        stateStackSize: function(),\r\n *        cleanupAfterLex: function()\r\n *\r\n *        options: { ... lexer %options ... },\r\n *\r\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\r\n *        rules: [...],\r\n *        conditions: {associative list: name ==> set},\r\n *    }\r\n *  }\r\n *\r\n *\r\n *  token location info (@$, _$, etc.): {\r\n *    first_line: n,\r\n *    last_line: n,\r\n *    first_column: n,\r\n *    last_column: n,\r\n *    range: [start_number, end_number]\r\n *               (where the numbers are indexes into the input string, zero-based)\r\n *  }\r\n *\r\n * ---\r\n *\r\n * The `parseError` function receives a 'hash' object with these members for lexer and\r\n * parser errors:\r\n *\r\n *  {\r\n *    text:        (matched text)\r\n *    token:       (the produced terminal token, if any)\r\n *    token_id:    (the produced terminal token numeric ID, if any)\r\n *    line:        (yylineno)\r\n *    loc:         (yylloc)\r\n *  }\r\n *\r\n * parser (grammar) errors will also provide these additional members:\r\n *\r\n *  {\r\n *    expected:    (array describing the set of expected tokens;\r\n *                  may be UNDEFINED when we cannot easily produce such a set)\r\n *    state:       (integer (or array when the table includes grammar collisions);\r\n *                  represents the current internal state of the parser kernel.\r\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\r\n *                  API to obtain the expected token set)\r\n *    action:      (integer; represents the current internal action which will be executed)\r\n *    new_state:   (integer; represents the next/planned internal state, once the current\r\n *                  action has executed)\r\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\r\n *                  available for this particular error)\r\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    yy:          (object: the current parser internal \"shared state\" `yy`\r\n *                  as is also available in the rule actions; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    lexer:       (reference to the current lexer instance used by the parser)\r\n *    parser:      (reference to the current parser instance)\r\n *  }\r\n *\r\n * while `this` will reference the current parser instance.\r\n *\r\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\r\n * instance, while these additional `hash` fields will also be provided:\r\n *\r\n *  {\r\n *    lexer:       (reference to the current lexer instance which reported the error)\r\n *  }\r\n *\r\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\r\n * from either the parser or lexer, `this` will still reference the related *parser*\r\n * instance, while these additional `hash` fields will also be provided:\r\n *\r\n *  {\r\n *    exception:   (reference to the exception thrown)\r\n *  }\r\n *\r\n * Please do note that in the latter situation, the `expected` field will be omitted as\r\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\r\n * action code in either parser or lexer failing unexpectedly.\r\n *\r\n * ---\r\n *\r\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\r\n * These options are available:\r\n *\r\n * ### options which are global for all parser instances\r\n *\r\n *  Parser.pre_parse: function(yy)\r\n *                 optional: you can specify a pre_parse() function in the chunk following\r\n *                 the grammar, i.e. after the last `%%`.\r\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\r\n *                 optional: you can specify a post_parse() function in the chunk following\r\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\r\n *                 the parser will return the original `retval`.\r\n *\r\n * ### options which can be set up per parser instance\r\n *\r\n *  yy: {\r\n *      pre_parse:  function(yy)\r\n *                 optional: is invoked before the parse cycle starts (and before the first\r\n *                 invocation of `lex()`) but immediately after the invocation of\r\n *                 `parser.pre_parse()`).\r\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\r\n *                 optional: is invoked when the parse terminates due to success ('accept')\r\n *                 or failure (even when exceptions are thrown).\r\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\r\n *                 this function can override the return value by returning another.\r\n *                 When it does not return any value, the parser will return the original\r\n *                 `retval`.\r\n *                 This function is invoked immediately before `parser.post_parse()`.\r\n *\r\n *      parseError: function(str, hash, ExceptionClass)\r\n *                 optional: overrides the default `parseError` function.\r\n *      quoteName: function(name),\r\n *                 optional: overrides the default `quoteName` function.\r\n *  }\r\n *\r\n *  parser.lexer.options: {\r\n *      pre_lex:  function()\r\n *                 optional: is invoked before the lexer is invoked to produce another token.\r\n *                 `this` refers to the Lexer object.\r\n *      post_lex: function(token) { return token; }\r\n *                 optional: is invoked when the lexer has produced a token `token`;\r\n *                 this function can override the returned token value by returning another.\r\n *                 When it does not return any (truthy) value, the lexer will return\r\n *                 the original `token`.\r\n *                 `this` refers to the Lexer object.\r\n *\r\n *      ranges: boolean\r\n *                 optional: `true` ==> token location info will include a .range[] member.\r\n *      flex: boolean\r\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\r\n *                 exhaustively to find the longest match.\r\n *      backtrack_lexer: boolean\r\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\r\n *                 the lexer terminates the scan when a token is returned by the action code.\r\n *      xregexp: boolean\r\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\r\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\r\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\r\n *  }\r\n */\r\n\r\n/** @type {Parser} */\r\nvar parser = (function () {\r\n  // See also:\r\n  // http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\r\n  // but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\r\n  // with userland code which might access the derived class in a 'classic' way.\r\n  function JisonParserError(msg, hash) {\r\n    Object.defineProperty(this, \"name\", {\r\n      enumerable: false,\r\n      writable: false,\r\n      value: \"JisonParserError\",\r\n    });\r\n\r\n    if (msg == null) msg = \"???\";\r\n\r\n    Object.defineProperty(this, \"message\", {\r\n      enumerable: false,\r\n      writable: true,\r\n      value: msg,\r\n    });\r\n\r\n    this.hash = hash;\r\n\r\n    var stacktrace;\r\n    if (hash && hash.exception instanceof Error) {\r\n      var ex2 = hash.exception;\r\n      this.message = ex2.message || msg;\r\n      stacktrace = ex2.stack;\r\n    }\r\n    if (!stacktrace) {\r\n      if (Error.hasOwnProperty(\"captureStackTrace\")) {\r\n        // V8/Chrome engine\r\n        Error.captureStackTrace(this, this.constructor);\r\n      } else {\r\n        stacktrace = new Error(msg).stack;\r\n      }\r\n    }\r\n    if (stacktrace) {\r\n      Object.defineProperty(this, \"stack\", {\r\n        enumerable: false,\r\n        writable: false,\r\n        value: stacktrace,\r\n      });\r\n    }\r\n  }\r\n\r\n  if (typeof Object.setPrototypeOf === \"function\") {\r\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\r\n  } else {\r\n    JisonParserError.prototype = Object.create(Error.prototype);\r\n  }\r\n  JisonParserError.prototype.constructor = JisonParserError;\r\n  JisonParserError.prototype.name = \"JisonParserError\";\r\n\r\n  // helper: reconstruct the productions[] table\r\n  function bp(s) {\r\n    var rv = [];\r\n    var p = s.pop;\r\n    var r = s.rule;\r\n    for (var i = 0, l = p.length; i < l; i++) {\r\n      rv.push([p[i], r[i]]);\r\n    }\r\n    return rv;\r\n  }\r\n\r\n  // helper: reconstruct the defaultActions[] table\r\n  function bda(s) {\r\n    var rv = {};\r\n    var d = s.idx;\r\n    var g = s.goto;\r\n    for (var i = 0, l = d.length; i < l; i++) {\r\n      var j = d[i];\r\n      rv[j] = g[i];\r\n    }\r\n    return rv;\r\n  }\r\n\r\n  // helper: reconstruct the 'goto' table\r\n  function bt(s) {\r\n    var rv = [];\r\n    var d = s.len;\r\n    var y = s.symbol;\r\n    var t = s.type;\r\n    var a = s.state;\r\n    var m = s.mode;\r\n    var g = s.goto;\r\n    for (var i = 0, l = d.length; i < l; i++) {\r\n      var n = d[i];\r\n      var q = {};\r\n      for (var j = 0; j < n; j++) {\r\n        var z = y.shift();\r\n        switch (t.shift()) {\r\n          case 2:\r\n            q[z] = [m.shift(), g.shift()];\r\n            break;\r\n\r\n          case 0:\r\n            q[z] = a.shift();\r\n            break;\r\n\r\n          default:\r\n            // type === 1: accept\r\n            q[z] = [3];\r\n        }\r\n      }\r\n      rv.push(q);\r\n    }\r\n    return rv;\r\n  }\r\n\r\n  // helper: runlength encoding with increment step: code, length: step (default step = 0)\r\n  // `this` references an array\r\n  function s(c, l, a) {\r\n    a = a || 0;\r\n    for (var i = 0; i < l; i++) {\r\n      this.push(c);\r\n      c += a;\r\n    }\r\n  }\r\n\r\n  // helper: duplicate sequence from *relative* offset and length.\r\n  // `this` references an array\r\n  function c(i, l) {\r\n    i = this.length - i;\r\n    for (l += i; i < l; i++) {\r\n      this.push(this[i]);\r\n    }\r\n  }\r\n\r\n  // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\r\n  function u(a) {\r\n    var rv = [];\r\n    for (var i = 0, l = a.length; i < l; i++) {\r\n      var e = a[i];\r\n      // Is this entry a helper function?\r\n      if (typeof e === \"function\") {\r\n        i++;\r\n        e.apply(rv, a[i]);\r\n      } else {\r\n        rv.push(e);\r\n      }\r\n    }\r\n    return rv;\r\n  }\r\n\r\n  var parser = {\r\n    // Code Generator Information Report\r\n    // ---------------------------------\r\n    //\r\n    // Options:\r\n    //\r\n    //   default action mode: ............. [\"classic\",\"merge\"]\r\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\r\n    //   try..catch: ...................... true\r\n    //   default resolve on conflict: ..... true\r\n    //   on-demand look-ahead: ............ false\r\n    //   error recovery token skip maximum: 3\r\n    //   yyerror in parse actions is: ..... NOT recoverable,\r\n    //   yyerror in lexer actions and other non-fatal lexer are:\r\n    //   .................................. NOT recoverable,\r\n    //   debug grammar/output: ............ false\r\n    //   has partial LR conflict upgrade:   true\r\n    //   rudimentary token-stack support:   false\r\n    //   parser table compression mode: ... 2\r\n    //   export debug tables: ............. false\r\n    //   export *all* tables: ............. false\r\n    //   module type: ..................... commonjs\r\n    //   parser engine type: .............. lalr\r\n    //   output main() in the module: ..... true\r\n    //   has user-specified main(): ....... false\r\n    //   has user-specified require()/import modules for main():\r\n    //   .................................. false\r\n    //   number of expected conflicts: .... 0\r\n    //\r\n    //\r\n    // Parser Analysis flags:\r\n    //\r\n    //   no significant actions (parser is a language matcher only):\r\n    //   .................................. false\r\n    //   uses yyleng: ..................... false\r\n    //   uses yylineno: ................... false\r\n    //   uses yytext: ..................... false\r\n    //   uses yylloc: ..................... false\r\n    //   uses ParseError API: ............. false\r\n    //   uses YYERROR: .................... false\r\n    //   uses YYRECOVERING: ............... false\r\n    //   uses YYERROK: .................... false\r\n    //   uses YYCLEARIN: .................. false\r\n    //   tracks rule values: .............. true\r\n    //   assigns rule values: ............. true\r\n    //   uses location tracking: .......... false\r\n    //   assigns location: ................ false\r\n    //   uses yystack: .................... false\r\n    //   uses yysstack: ................... false\r\n    //   uses yysp: ....................... true\r\n    //   uses yyrulelength: ............... false\r\n    //   uses yyMergeLocationInfo API: .... false\r\n    //   has error recovery: .............. false\r\n    //   has error reporting: ............. false\r\n    //\r\n    // --------- END OF REPORT -----------\r\n\r\n    trace: function no_op_trace() {},\r\n    JisonParserError: JisonParserError,\r\n    yy: {},\r\n    options: {\r\n      type: \"lalr\",\r\n      hasPartialLrUpgradeOnConflict: true,\r\n      errorRecoveryTokenDiscardCount: 3,\r\n    },\r\n    symbols_: {\r\n      $accept: 0,\r\n      $end: 1,\r\n      ADD: 3,\r\n      ANGLE: 18,\r\n      CHS: 24,\r\n      COMMA: 11,\r\n      CSS_CPROP: 16,\r\n      CSS_VAR: 15,\r\n      DIV: 6,\r\n      EMS: 22,\r\n      EOF: 1,\r\n      EXS: 23,\r\n      FREQ: 20,\r\n      LENGTH: 17,\r\n      LPAREN: 7,\r\n      MAX: 10,\r\n      MIN: 12,\r\n      MUL: 5,\r\n      NESTED_CALC: 9,\r\n      NUMBER: 14,\r\n      PERCENTAGE: 30,\r\n      PREFIX: 13,\r\n      REMS: 25,\r\n      RES: 21,\r\n      RPAREN: 8,\r\n      SUB: 4,\r\n      TIME: 19,\r\n      VHS: 26,\r\n      VMAXS: 29,\r\n      VMINS: 28,\r\n      VWS: 27,\r\n      css_value: 35,\r\n      css_variable: 34,\r\n      error: 2,\r\n      expression: 31,\r\n      math_expression: 32,\r\n      value: 33,\r\n    },\r\n    terminals_: {\r\n      1: \"EOF\",\r\n      2: \"error\",\r\n      3: \"ADD\",\r\n      4: \"SUB\",\r\n      5: \"MUL\",\r\n      6: \"DIV\",\r\n      7: \"LPAREN\",\r\n      8: \"RPAREN\",\r\n      9: \"NESTED_CALC\",\r\n      10: \"MAX\",\r\n      11: \"COMMA\",\r\n      12: \"MIN\",\r\n      13: \"PREFIX\",\r\n      14: \"NUMBER\",\r\n      15: \"CSS_VAR\",\r\n      16: \"CSS_CPROP\",\r\n      17: \"LENGTH\",\r\n      18: \"ANGLE\",\r\n      19: \"TIME\",\r\n      20: \"FREQ\",\r\n      21: \"RES\",\r\n      22: \"EMS\",\r\n      23: \"EXS\",\r\n      24: \"CHS\",\r\n      25: \"REMS\",\r\n      26: \"VHS\",\r\n      27: \"VWS\",\r\n      28: \"VMINS\",\r\n      29: \"VMAXS\",\r\n      30: \"PERCENTAGE\",\r\n    },\r\n    TERROR: 2,\r\n    EOF: 1,\r\n\r\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\r\n    // thus helping JIT compilers like Chrome V8.\r\n    originalQuoteName: null,\r\n    originalParseError: null,\r\n    cleanupAfterParse: null,\r\n    constructParseErrorInfo: null,\r\n    yyMergeLocationInfo: null,\r\n\r\n    __reentrant_call_depth: 0, // INTERNAL USE ONLY\r\n    __error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\r\n    __error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\r\n\r\n    // APIs which will be set up depending on user action code analysis:\r\n    //yyRecovering: 0,\r\n    //yyErrOk: 0,\r\n    //yyClearIn: 0,\r\n\r\n    // Helper APIs\r\n    // -----------\r\n\r\n    // Helper function which can be overridden by user code later on: put suitable quotes around\r\n    // literal IDs in a description string.\r\n    quoteName: function parser_quoteName(id_str) {\r\n      return '\"' + id_str + '\"';\r\n    },\r\n\r\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\r\n    //\r\n    // Return NULL when the symbol is unknown to the parser.\r\n    getSymbolName: function parser_getSymbolName(symbol) {\r\n      if (this.terminals_[symbol]) {\r\n        return this.terminals_[symbol];\r\n      }\r\n\r\n      // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\r\n      //\r\n      // An example of this may be where a rule's action code contains a call like this:\r\n      //\r\n      //      parser.getSymbolName(#$)\r\n      //\r\n      // to obtain a human-readable name of the current grammar rule.\r\n      var s = this.symbols_;\r\n      for (var key in s) {\r\n        if (s[key] === symbol) {\r\n          return key;\r\n        }\r\n      }\r\n      return null;\r\n    },\r\n\r\n    // Return a more-or-less human-readable description of the given symbol, when available,\r\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\r\n    //\r\n    // Return NULL when the symbol is unknown to the parser.\r\n    describeSymbol: function parser_describeSymbol(symbol) {\r\n      if (\r\n        symbol !== this.EOF &&\r\n        this.terminal_descriptions_ &&\r\n        this.terminal_descriptions_[symbol]\r\n      ) {\r\n        return this.terminal_descriptions_[symbol];\r\n      } else if (symbol === this.EOF) {\r\n        return \"end of input\";\r\n      }\r\n      var id = this.getSymbolName(symbol);\r\n      if (id) {\r\n        return this.quoteName(id);\r\n      }\r\n      return null;\r\n    },\r\n\r\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\r\n    //\r\n    // The produced list may contain token or token set descriptions instead of the tokens\r\n    // themselves to help turning this output into something that easier to read by humans\r\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\r\n    // expected terminals and nonterminals is produced.\r\n    //\r\n    // The returned list (array) will not contain any duplicate entries.\r\n    collect_expected_token_set: function parser_collect_expected_token_set(\r\n      state,\r\n      do_not_describe\r\n    ) {\r\n      var TERROR = this.TERROR;\r\n      var tokenset = [];\r\n      var check = {};\r\n      // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\r\n      // If so, use that one instead of the less palatable token set.\r\n      if (\r\n        !do_not_describe &&\r\n        this.state_descriptions_ &&\r\n        this.state_descriptions_[state]\r\n      ) {\r\n        return [this.state_descriptions_[state]];\r\n      }\r\n      for (var p in this.table[state]) {\r\n        p = +p;\r\n        if (p !== TERROR) {\r\n          var d = do_not_describe ? p : this.describeSymbol(p);\r\n          if (d && !check[d]) {\r\n            tokenset.push(d);\r\n            check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.\r\n          }\r\n        }\r\n      }\r\n      return tokenset;\r\n    },\r\n    productions_: bp({\r\n      pop: u([31, s, [32, 12], 33, 33, 34, 34, s, [35, 15]]),\r\n      rule: u([2, s, [3, 5], 4, 6, 6, 7, s, [1, 4], 2, 4, 6, s, [1, 14], 2]),\r\n    }),\r\n    performAction: function parser__PerformAction(\r\n      yystate /* action[1] */,\r\n      yysp,\r\n      yyvstack\r\n    ) {\r\n      /* this == yyval */\r\n\r\n      // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\r\n      var yy = this.yy;\r\n      var yyparser = yy.parser;\r\n      var yylexer = yy.lexer;\r\n\r\n      switch (yystate) {\r\n        case 0:\r\n          /*! Production::    $accept : expression $end */\r\n\r\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):\r\n          this.$ = yyvstack[yysp - 1];\r\n          // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)\r\n          break;\r\n\r\n        case 1:\r\n          /*! Production::    expression : math_expression EOF */\r\n\r\n          // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):\r\n          this.$ = yyvstack[yysp - 1];\r\n          // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)\r\n\r\n          return yyvstack[yysp - 1];\r\n          break;\r\n\r\n        case 2:\r\n        /*! Production::    math_expression : math_expression ADD math_expression */\r\n        case 3:\r\n        /*! Production::    math_expression : math_expression SUB math_expression */\r\n        case 4:\r\n        /*! Production::    math_expression : math_expression MUL math_expression */\r\n        case 5:\r\n          /*! Production::    math_expression : math_expression DIV math_expression */\r\n\r\n          this.$ = {\r\n            type: \"MathExpression\",\r\n            operator: yyvstack[yysp - 1],\r\n            left: yyvstack[yysp - 2],\r\n            right: yyvstack[yysp],\r\n          };\r\n          break;\r\n\r\n        case 6:\r\n          /*! Production::    math_expression : LPAREN math_expression RPAREN */\r\n\r\n          this.$ = yyvstack[yysp - 1];\r\n          break;\r\n\r\n        case 7:\r\n          /*! Production::    math_expression : NESTED_CALC LPAREN math_expression RPAREN */\r\n\r\n          this.$ = { type: \"Calc\", value: yyvstack[yysp - 1] };\r\n          break;\r\n\r\n        case 8:\r\n          /*! Production::    math_expression : MAX LPAREN math_expression COMMA math_expression RPAREN */\r\n\r\n          this.$ = {\r\n            type: \"MathExpression\",\r\n            operator: \"max\",\r\n            left: yyvstack[yysp - 3],\r\n            right: yyvstack[yysp - 1],\r\n          };\r\n          break;\r\n\r\n        case 9:\r\n          /*! Production::    math_expression : MIN LPAREN math_expression COMMA math_expression RPAREN */\r\n\r\n          this.$ = {\r\n            type: \"MathExpression\",\r\n            operator: \"min\",\r\n            left: yyvstack[yysp - 3],\r\n            right: yyvstack[yysp - 1],\r\n          };\r\n          break;\r\n\r\n        case 10:\r\n          /*! Production::    math_expression : SUB PREFIX SUB NESTED_CALC LPAREN math_expression RPAREN */\r\n\r\n          this.$ = {\r\n            type: \"Calc\",\r\n            value: yyvstack[yysp - 1],\r\n            prefix: yyvstack[yysp - 5],\r\n          };\r\n          break;\r\n\r\n        case 11:\r\n        /*! Production::    math_expression : css_variable */\r\n        case 12:\r\n        /*! Production::    math_expression : css_value */\r\n        case 13:\r\n          /*! Production::    math_expression : value */\r\n\r\n          this.$ = yyvstack[yysp];\r\n          break;\r\n\r\n        case 14:\r\n          /*! Production::    value : NUMBER */\r\n\r\n          this.$ = { type: \"Value\", value: parseFloat(yyvstack[yysp]) };\r\n          break;\r\n\r\n        case 15:\r\n          /*! Production::    value : SUB NUMBER */\r\n\r\n          this.$ = { type: \"Value\", value: parseFloat(yyvstack[yysp]) * -1 };\r\n          break;\r\n\r\n        case 16:\r\n          /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP RPAREN */\r\n\r\n          this.$ = { type: \"CssVariable\", value: yyvstack[yysp - 1] };\r\n          break;\r\n\r\n        case 17:\r\n          /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP COMMA math_expression RPAREN */\r\n\r\n          this.$ = {\r\n            type: \"CssVariable\",\r\n            value: yyvstack[yysp - 3],\r\n            fallback: yyvstack[yysp - 1],\r\n          };\r\n          break;\r\n\r\n        case 18:\r\n          /*! Production::    css_value : LENGTH */\r\n\r\n          this.$ = {\r\n            type: \"LengthValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0],\r\n          };\r\n          break;\r\n\r\n        case 19:\r\n          /*! Production::    css_value : ANGLE */\r\n\r\n          this.$ = {\r\n            type: \"AngleValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0],\r\n          };\r\n          break;\r\n\r\n        case 20:\r\n          /*! Production::    css_value : TIME */\r\n\r\n          this.$ = {\r\n            type: \"TimeValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0],\r\n          };\r\n          break;\r\n\r\n        case 21:\r\n          /*! Production::    css_value : FREQ */\r\n\r\n          this.$ = {\r\n            type: \"FrequencyValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0],\r\n          };\r\n          break;\r\n\r\n        case 22:\r\n          /*! Production::    css_value : RES */\r\n\r\n          this.$ = {\r\n            type: \"ResolutionValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0],\r\n          };\r\n          break;\r\n\r\n        case 23:\r\n          /*! Production::    css_value : EMS */\r\n\r\n          this.$ = {\r\n            type: \"EmValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"em\",\r\n          };\r\n          break;\r\n\r\n        case 24:\r\n          /*! Production::    css_value : EXS */\r\n\r\n          this.$ = {\r\n            type: \"ExValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"ex\",\r\n          };\r\n          break;\r\n\r\n        case 25:\r\n          /*! Production::    css_value : CHS */\r\n\r\n          this.$ = {\r\n            type: \"ChValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"ch\",\r\n          };\r\n          break;\r\n\r\n        case 26:\r\n          /*! Production::    css_value : REMS */\r\n\r\n          this.$ = {\r\n            type: \"RemValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"rem\",\r\n          };\r\n          break;\r\n\r\n        case 27:\r\n          /*! Production::    css_value : VHS */\r\n\r\n          this.$ = {\r\n            type: \"VhValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"vh\",\r\n          };\r\n          break;\r\n\r\n        case 28:\r\n          /*! Production::    css_value : VWS */\r\n\r\n          this.$ = {\r\n            type: \"VwValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"vw\",\r\n          };\r\n          break;\r\n\r\n        case 29:\r\n          /*! Production::    css_value : VMINS */\r\n\r\n          this.$ = {\r\n            type: \"VminValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"vmin\",\r\n          };\r\n          break;\r\n\r\n        case 30:\r\n          /*! Production::    css_value : VMAXS */\r\n\r\n          this.$ = {\r\n            type: \"VmaxValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"vmax\",\r\n          };\r\n          break;\r\n\r\n        case 31:\r\n          /*! Production::    css_value : PERCENTAGE */\r\n\r\n          this.$ = {\r\n            type: \"PercentageValue\",\r\n            value: parseFloat(yyvstack[yysp]),\r\n            unit: \"%\",\r\n          };\r\n          break;\r\n\r\n        case 32:\r\n          /*! Production::    css_value : SUB css_value */\r\n\r\n          var prev = yyvstack[yysp];\r\n          prev.value *= -1;\r\n          this.$ = prev;\r\n          break;\r\n      }\r\n    },\r\n    table: bt({\r\n      len: u([\r\n        26,\r\n        1,\r\n        5,\r\n        25,\r\n        s,\r\n        [1, 3],\r\n        18,\r\n        s,\r\n        [0, 3],\r\n        1,\r\n        s,\r\n        [0, 16],\r\n        s,\r\n        [25, 4],\r\n        5,\r\n        s,\r\n        [25, 3],\r\n        c,\r\n        [25, 3],\r\n        16,\r\n        1,\r\n        7,\r\n        7,\r\n        s,\r\n        [0, 3],\r\n        s,\r\n        [5, 3],\r\n        1,\r\n        2,\r\n        c,\r\n        [24, 3],\r\n        1,\r\n        0,\r\n        25,\r\n        5,\r\n        5,\r\n        25,\r\n        5,\r\n        c,\r\n        [17, 3],\r\n        0,\r\n        0,\r\n      ]),\r\n      symbol: u([\r\n        4,\r\n        7,\r\n        9,\r\n        10,\r\n        12,\r\n        14,\r\n        15,\r\n        s,\r\n        [17, 19, 1],\r\n        1,\r\n        1,\r\n        s,\r\n        [3, 4, 1],\r\n        c,\r\n        [32, 21],\r\n        c,\r\n        [31, 4],\r\n        s,\r\n        [7, 3],\r\n        4,\r\n        13,\r\n        14,\r\n        c,\r\n        [24, 14],\r\n        35,\r\n        7,\r\n        c,\r\n        [47, 25],\r\n        c,\r\n        [25, 75],\r\n        c,\r\n        [151, 4],\r\n        8,\r\n        c,\r\n        [105, 76],\r\n        4,\r\n        c,\r\n        [198, 15],\r\n        16,\r\n        c,\r\n        [250, 5],\r\n        8,\r\n        11,\r\n        c,\r\n        [7, 7],\r\n        c,\r\n        [6, 5],\r\n        c,\r\n        [5, 4],\r\n        c,\r\n        [10, 5],\r\n        11,\r\n        9,\r\n        8,\r\n        11,\r\n        c,\r\n        [100, 50],\r\n        c,\r\n        [281, 26],\r\n        c,\r\n        [94, 9],\r\n        c,\r\n        [211, 26],\r\n        c,\r\n        [35, 10],\r\n      ]),\r\n      type: u([\r\n        s,\r\n        [2, 21],\r\n        s,\r\n        [0, 5],\r\n        1,\r\n        s,\r\n        [2, 26],\r\n        s,\r\n        [0, 4],\r\n        c,\r\n        [24, 21],\r\n        c,\r\n        [47, 46],\r\n        c,\r\n        [25, 76],\r\n        c,\r\n        [80, 75],\r\n        c,\r\n        [97, 27],\r\n        s,\r\n        [2, 28],\r\n        c,\r\n        [180, 51],\r\n        c,\r\n        [206, 30],\r\n        c,\r\n        [35, 19],\r\n      ]),\r\n      state: u([\r\n        1,\r\n        2,\r\n        10,\r\n        8,\r\n        9,\r\n        32,\r\n        c,\r\n        [4, 3],\r\n        37,\r\n        41,\r\n        c,\r\n        [5, 3],\r\n        42,\r\n        c,\r\n        [4, 3],\r\n        43,\r\n        c,\r\n        [4, 3],\r\n        44,\r\n        c,\r\n        [4, 3],\r\n        46,\r\n        c,\r\n        [4, 3],\r\n        47,\r\n        c,\r\n        [4, 3],\r\n        48,\r\n        c,\r\n        [29, 4],\r\n        57,\r\n        c,\r\n        [5, 3],\r\n        58,\r\n        c,\r\n        [4, 3],\r\n        60,\r\n        c,\r\n        [4, 3],\r\n        63,\r\n        c,\r\n        [4, 3],\r\n      ]),\r\n      mode: u([s, [1, 237], s, [2, 3], c, [5, 5], c, [7, 6], s, [1, 123]]),\r\n      goto: u([\r\n        7,\r\n        s,\r\n        [3, 4, 1],\r\n        26,\r\n        s,\r\n        [11, 15, 1],\r\n        s,\r\n        [27, 5, 1],\r\n        c,\r\n        [26, 21],\r\n        33,\r\n        34,\r\n        35,\r\n        39,\r\n        36,\r\n        38,\r\n        c,\r\n        [20, 14],\r\n        40,\r\n        c,\r\n        [42, 21],\r\n        c,\r\n        [21, 63],\r\n        c,\r\n        [130, 4],\r\n        45,\r\n        c,\r\n        [68, 63],\r\n        49,\r\n        39,\r\n        c,\r\n        [16, 14],\r\n        50,\r\n        s,\r\n        [2, 3],\r\n        30,\r\n        31,\r\n        2,\r\n        2,\r\n        s,\r\n        [3, 3],\r\n        30,\r\n        31,\r\n        3,\r\n        3,\r\n        c,\r\n        [99, 4],\r\n        51,\r\n        c,\r\n        [5, 4],\r\n        52,\r\n        c,\r\n        [5, 4],\r\n        s,\r\n        [53, 4, 1],\r\n        c,\r\n        [91, 42],\r\n        59,\r\n        c,\r\n        [181, 25],\r\n        61,\r\n        c,\r\n        [5, 4],\r\n        62,\r\n        c,\r\n        [31, 25],\r\n        64,\r\n        c,\r\n        [5, 4],\r\n        65,\r\n      ]),\r\n    }),\r\n    defaultActions: bda({\r\n      idx: u([\r\n        8,\r\n        9,\r\n        10,\r\n        s,\r\n        [12, 16, 1],\r\n        37,\r\n        38,\r\n        43,\r\n        44,\r\n        45,\r\n        51,\r\n        55,\r\n        61,\r\n        62,\r\n        64,\r\n        65,\r\n      ]),\r\n      goto: u([\r\n        11,\r\n        12,\r\n        13,\r\n        s,\r\n        [18, 14, 1],\r\n        14,\r\n        1,\r\n        32,\r\n        15,\r\n        s,\r\n        [4, 4, 1],\r\n        16,\r\n        8,\r\n        9,\r\n        17,\r\n        10,\r\n      ]),\r\n    }),\r\n    parseError: function parseError(str, hash, ExceptionClass) {\r\n      if (hash.recoverable) {\r\n        if (typeof this.trace === \"function\") {\r\n          this.trace(str);\r\n        }\r\n        hash.destroy(); // destroy... well, *almost*!\r\n      } else {\r\n        if (typeof this.trace === \"function\") {\r\n          this.trace(str);\r\n        }\r\n        if (!ExceptionClass) {\r\n          ExceptionClass = this.JisonParserError;\r\n        }\r\n        throw new ExceptionClass(str, hash);\r\n      }\r\n    },\r\n    parse: function parse(input) {\r\n      var self = this;\r\n      var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)\r\n      var sstack = new Array(128); // state stack: stores states (column storage)\r\n\r\n      var vstack = new Array(128); // semantic value stack\r\n\r\n      var table = this.table;\r\n      var sp = 0; // 'stack pointer': index into the stacks\r\n\r\n      var symbol = 0;\r\n\r\n      var TERROR = this.TERROR;\r\n      var EOF = this.EOF;\r\n      var ERROR_RECOVERY_TOKEN_DISCARD_COUNT =\r\n        this.options.errorRecoveryTokenDiscardCount | 0 || 3;\r\n      var NO_ACTION = [\r\n        0,\r\n        66 /* === table.length :: ensures that anyone using this new state will fail dramatically! */,\r\n      ];\r\n\r\n      var lexer;\r\n      if (this.__lexer__) {\r\n        lexer = this.__lexer__;\r\n      } else {\r\n        lexer = this.__lexer__ = Object.create(this.lexer);\r\n      }\r\n\r\n      var sharedState_yy = {\r\n        parseError: undefined,\r\n        quoteName: undefined,\r\n        lexer: undefined,\r\n        parser: undefined,\r\n        pre_parse: undefined,\r\n        post_parse: undefined,\r\n        pre_lex: undefined,\r\n        post_lex: undefined, // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\r\n      };\r\n\r\n      var ASSERT;\r\n      if (typeof assert !== \"function\") {\r\n        ASSERT = function JisonAssert(cond, msg) {\r\n          if (!cond) {\r\n            throw new Error(\"assertion failed: \" + (msg || \"***\"));\r\n          }\r\n        };\r\n      } else {\r\n        ASSERT = assert;\r\n      }\r\n\r\n      this.yyGetSharedState = function yyGetSharedState() {\r\n        return sharedState_yy;\r\n      };\r\n\r\n      function shallow_copy_noclobber(dst, src) {\r\n        for (var k in src) {\r\n          if (\r\n            typeof dst[k] === \"undefined\" &&\r\n            Object.prototype.hasOwnProperty.call(src, k)\r\n          ) {\r\n            dst[k] = src[k];\r\n          }\r\n        }\r\n      }\r\n\r\n      // copy state\r\n      shallow_copy_noclobber(sharedState_yy, this.yy);\r\n\r\n      sharedState_yy.lexer = lexer;\r\n      sharedState_yy.parser = this;\r\n\r\n      // Does the shared state override the default `parseError` that already comes with this instance?\r\n      if (typeof sharedState_yy.parseError === \"function\") {\r\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\r\n          if (!ExceptionClass) {\r\n            ExceptionClass = this.JisonParserError;\r\n          }\r\n          return sharedState_yy.parseError.call(\r\n            this,\r\n            str,\r\n            hash,\r\n            ExceptionClass\r\n          );\r\n        };\r\n      } else {\r\n        this.parseError = this.originalParseError;\r\n      }\r\n\r\n      // Does the shared state override the default `quoteName` that already comes with this instance?\r\n      if (typeof sharedState_yy.quoteName === \"function\") {\r\n        this.quoteName = function quoteNameAlt(id_str) {\r\n          return sharedState_yy.quoteName.call(this, id_str);\r\n        };\r\n      } else {\r\n        this.quoteName = this.originalQuoteName;\r\n      }\r\n\r\n      // set up the cleanup function; make it an API so that external code can re-use this one in case of\r\n      // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\r\n      // case this parse() API method doesn't come with a `finally { ... }` block any more!\r\n      //\r\n      // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\r\n      //       or else your `sharedState`, etc. references will be *wrong*!\r\n      this.cleanupAfterParse = function parser_cleanupAfterParse(\r\n        resultValue,\r\n        invoke_post_methods,\r\n        do_not_nuke_errorinfos\r\n      ) {\r\n        var rv;\r\n\r\n        if (invoke_post_methods) {\r\n          var hash;\r\n\r\n          if (sharedState_yy.post_parse || this.post_parse) {\r\n            // create an error hash info instance: we re-use this API in a **non-error situation**\r\n            // as this one delivers all parser internals ready for access by userland code.\r\n            hash = this.constructParseErrorInfo(\r\n              null /* no error! */,\r\n              null /* no exception! */,\r\n              null,\r\n              false\r\n            );\r\n          }\r\n\r\n          if (sharedState_yy.post_parse) {\r\n            rv = sharedState_yy.post_parse.call(\r\n              this,\r\n              sharedState_yy,\r\n              resultValue,\r\n              hash\r\n            );\r\n            if (typeof rv !== \"undefined\") resultValue = rv;\r\n          }\r\n          if (this.post_parse) {\r\n            rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\r\n            if (typeof rv !== \"undefined\") resultValue = rv;\r\n          }\r\n\r\n          // cleanup:\r\n          if (hash && hash.destroy) {\r\n            hash.destroy();\r\n          }\r\n        }\r\n\r\n        if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.\r\n\r\n        // clean up the lingering lexer structures as well:\r\n        if (lexer.cleanupAfterLex) {\r\n          lexer.cleanupAfterLex(do_not_nuke_errorinfos);\r\n        }\r\n\r\n        // prevent lingering circular references from causing memory leaks:\r\n        if (sharedState_yy) {\r\n          sharedState_yy.lexer = undefined;\r\n          sharedState_yy.parser = undefined;\r\n          if (lexer.yy === sharedState_yy) {\r\n            lexer.yy = undefined;\r\n          }\r\n        }\r\n        sharedState_yy = undefined;\r\n        this.parseError = this.originalParseError;\r\n        this.quoteName = this.originalQuoteName;\r\n\r\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\r\n        // To be safe, we nuke the other internal stack columns as well...\r\n        stack.length = 0; // fastest way to nuke an array without overly bothering the GC\r\n        sstack.length = 0;\r\n\r\n        vstack.length = 0;\r\n        sp = 0;\r\n\r\n        // nuke the error hash info instances created during this run.\r\n        // Userland code must COPY any data/references\r\n        // in the error hash instance(s) it is more permanently interested in.\r\n        if (!do_not_nuke_errorinfos) {\r\n          for (var i = this.__error_infos.length - 1; i >= 0; i--) {\r\n            var el = this.__error_infos[i];\r\n            if (el && typeof el.destroy === \"function\") {\r\n              el.destroy();\r\n            }\r\n          }\r\n          this.__error_infos.length = 0;\r\n        }\r\n\r\n        return resultValue;\r\n      };\r\n\r\n      // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\r\n      //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\r\n      this.constructParseErrorInfo = function parser_constructParseErrorInfo(\r\n        msg,\r\n        ex,\r\n        expected,\r\n        recoverable\r\n      ) {\r\n        var pei = {\r\n          errStr: msg,\r\n          exception: ex,\r\n          text: lexer.match,\r\n          value: lexer.yytext,\r\n          token: this.describeSymbol(symbol) || symbol,\r\n          token_id: symbol,\r\n          line: lexer.yylineno,\r\n\r\n          expected: expected,\r\n          recoverable: recoverable,\r\n          state: state,\r\n          action: action,\r\n          new_state: newState,\r\n          symbol_stack: stack,\r\n          state_stack: sstack,\r\n          value_stack: vstack,\r\n\r\n          stack_pointer: sp,\r\n          yy: sharedState_yy,\r\n          lexer: lexer,\r\n          parser: this,\r\n\r\n          // and make sure the error info doesn't stay due to potential\r\n          // ref cycle via userland code manipulations.\r\n          // These would otherwise all be memory leak opportunities!\r\n          //\r\n          // Note that only array and object references are nuked as those\r\n          // constitute the set of elements which can produce a cyclic ref.\r\n          // The rest of the members is kept intact as they are harmless.\r\n          destroy: function destructParseErrorInfo() {\r\n            // remove cyclic references added to error info:\r\n            // info.yy = null;\r\n            // info.lexer = null;\r\n            // info.value = null;\r\n            // info.value_stack = null;\r\n            // ...\r\n            var rec = !!this.recoverable;\r\n            for (var key in this) {\r\n              if (this.hasOwnProperty(key) && typeof key === \"object\") {\r\n                this[key] = undefined;\r\n              }\r\n            }\r\n            this.recoverable = rec;\r\n          },\r\n        };\r\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\r\n        this.__error_infos.push(pei);\r\n        return pei;\r\n      };\r\n\r\n      function getNonTerminalFromCode(symbol) {\r\n        var tokenName = self.getSymbolName(symbol);\r\n        if (!tokenName) {\r\n          tokenName = symbol;\r\n        }\r\n        return tokenName;\r\n      }\r\n\r\n      function stdLex() {\r\n        var token = lexer.lex();\r\n        // if token isn't its numeric value, convert\r\n        if (typeof token !== \"number\") {\r\n          token = self.symbols_[token] || token;\r\n        }\r\n\r\n        return token || EOF;\r\n      }\r\n\r\n      function fastLex() {\r\n        var token = lexer.fastLex();\r\n        // if token isn't its numeric value, convert\r\n        if (typeof token !== \"number\") {\r\n          token = self.symbols_[token] || token;\r\n        }\r\n\r\n        return token || EOF;\r\n      }\r\n\r\n      var lex = stdLex;\r\n\r\n      var state, action, r, t;\r\n      var yyval = {\r\n        $: true,\r\n        _$: undefined,\r\n        yy: sharedState_yy,\r\n      };\r\n      var p;\r\n      var yyrulelen;\r\n      var this_production;\r\n      var newState;\r\n      var retval = false;\r\n\r\n      try {\r\n        this.__reentrant_call_depth++;\r\n\r\n        lexer.setInput(input, sharedState_yy);\r\n\r\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after*\r\n        // this initial `setInput()` call: hence we can now check and decide\r\n        // whether we'll go with the standard, slower, lex() API or the\r\n        // `fast_lex()` one:\r\n        if (typeof lexer.canIUse === \"function\") {\r\n          var lexerInfo = lexer.canIUse();\r\n          if (lexerInfo.fastLex && typeof fastLex === \"function\") {\r\n            lex = fastLex;\r\n          }\r\n        }\r\n\r\n        vstack[sp] = null;\r\n        sstack[sp] = 0;\r\n        stack[sp] = 0;\r\n        ++sp;\r\n\r\n        if (this.pre_parse) {\r\n          this.pre_parse.call(this, sharedState_yy);\r\n        }\r\n        if (sharedState_yy.pre_parse) {\r\n          sharedState_yy.pre_parse.call(this, sharedState_yy);\r\n        }\r\n\r\n        newState = sstack[sp - 1];\r\n        for (;;) {\r\n          // retrieve state number from top of stack\r\n          state = newState; // sstack[sp - 1];\r\n\r\n          // use default actions if available\r\n          if (this.defaultActions[state]) {\r\n            action = 2;\r\n            newState = this.defaultActions[state];\r\n          } else {\r\n            // The single `==` condition below covers both these `===` comparisons in a single\r\n            // operation:\r\n            //\r\n            //     if (symbol === null || typeof symbol === 'undefined') ...\r\n            if (!symbol) {\r\n              symbol = lex();\r\n            }\r\n            // read action for current state and first input\r\n            t = (table[state] && table[state][symbol]) || NO_ACTION;\r\n            newState = t[1];\r\n            action = t[0];\r\n\r\n            // handle parse error\r\n            if (!action) {\r\n              var errStr;\r\n              var errSymbolDescr = this.describeSymbol(symbol) || symbol;\r\n              var expected = this.collect_expected_token_set(state);\r\n\r\n              // Report error\r\n              if (typeof lexer.yylineno === \"number\") {\r\n                errStr = \"Parse error on line \" + (lexer.yylineno + 1) + \": \";\r\n              } else {\r\n                errStr = \"Parse error: \";\r\n              }\r\n              if (typeof lexer.showPosition === \"function\") {\r\n                errStr += \"\\n\" + lexer.showPosition(79 - 10, 10) + \"\\n\";\r\n              }\r\n              if (expected.length) {\r\n                errStr +=\r\n                  \"Expecting \" +\r\n                  expected.join(\", \") +\r\n                  \", got unexpected \" +\r\n                  errSymbolDescr;\r\n              } else {\r\n                errStr += \"Unexpected \" + errSymbolDescr;\r\n              }\r\n              // we cannot recover from the error!\r\n              p = this.constructParseErrorInfo(errStr, null, expected, false);\r\n              r = this.parseError(p.errStr, p, this.JisonParserError);\r\n              if (typeof r !== \"undefined\") {\r\n                retval = r;\r\n              }\r\n              break;\r\n            }\r\n          }\r\n\r\n          switch (action) {\r\n            // catch misc. parse failures:\r\n            default:\r\n              // this shouldn't happen, unless resolve defaults are off\r\n              if (action instanceof Array) {\r\n                p = this.constructParseErrorInfo(\r\n                  \"Parse Error: multiple actions possible at state: \" +\r\n                    state +\r\n                    \", token: \" +\r\n                    symbol,\r\n                  null,\r\n                  null,\r\n                  false\r\n                );\r\n                r = this.parseError(p.errStr, p, this.JisonParserError);\r\n                if (typeof r !== \"undefined\") {\r\n                  retval = r;\r\n                }\r\n                break;\r\n              }\r\n              // Another case of better safe than sorry: in case state transitions come out of another error recovery process\r\n              // or a buggy LUT (LookUp Table):\r\n              p = this.constructParseErrorInfo(\r\n                \"Parsing halted. No viable error recovery approach available due to internal system failure.\",\r\n                null,\r\n                null,\r\n                false\r\n              );\r\n              r = this.parseError(p.errStr, p, this.JisonParserError);\r\n              if (typeof r !== \"undefined\") {\r\n                retval = r;\r\n              }\r\n              break;\r\n\r\n            // shift:\r\n            case 1:\r\n              stack[sp] = symbol;\r\n              vstack[sp] = lexer.yytext;\r\n\r\n              sstack[sp] = newState; // push state\r\n\r\n              ++sp;\r\n              symbol = 0;\r\n\r\n              // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\r\n\r\n              continue;\r\n\r\n            // reduce:\r\n            case 2:\r\n              this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\r\n              yyrulelen = this_production[1];\r\n\r\n              r = this.performAction.call(yyval, newState, sp - 1, vstack);\r\n\r\n              if (typeof r !== \"undefined\") {\r\n                retval = r;\r\n                break;\r\n              }\r\n\r\n              // pop off stack\r\n              sp -= yyrulelen;\r\n\r\n              // don't overwrite the `symbol` variable: use a local var to speed things up:\r\n              var ntsymbol = this_production[0]; // push nonterminal (reduce)\r\n              stack[sp] = ntsymbol;\r\n              vstack[sp] = yyval.$;\r\n\r\n              // goto new state = table[STATE][NONTERMINAL]\r\n              newState = table[sstack[sp - 1]][ntsymbol];\r\n              sstack[sp] = newState;\r\n              ++sp;\r\n\r\n              continue;\r\n\r\n            // accept:\r\n            case 3:\r\n              if (sp !== -2) {\r\n                retval = true;\r\n                // Return the `$accept` rule's `$$` result, if available.\r\n                //\r\n                // Also note that JISON always adds this top-most `$accept` rule (with implicit,\r\n                // default, action):\r\n                //\r\n                //     $accept: <startSymbol> $end\r\n                //                  %{ $$ = $1; @$ = @1; %}\r\n                //\r\n                // which, combined with the parse kernel's `$accept` state behaviour coded below,\r\n                // will produce the `$$` value output of the <startSymbol> rule as the parse result,\r\n                // IFF that result is *not* `undefined`. (See also the parser kernel code.)\r\n                //\r\n                // In code:\r\n                //\r\n                //                  %{\r\n                //                      @$ = @1;            // if location tracking support is included\r\n                //                      if (typeof $1 !== 'undefined')\r\n                //                          return $1;\r\n                //                      else\r\n                //                          return true;           // the default parse result if the rule actions don't produce anything\r\n                //                  %}\r\n                sp--;\r\n                if (typeof vstack[sp] !== \"undefined\") {\r\n                  retval = vstack[sp];\r\n                }\r\n              }\r\n              break;\r\n          }\r\n\r\n          // break out of loop: we accept or fail with error\r\n          break;\r\n        }\r\n      } catch (ex) {\r\n        // report exceptions through the parseError callback too, but keep the exception intact\r\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\r\n        if (ex instanceof this.JisonParserError) {\r\n          throw ex;\r\n        } else if (\r\n          lexer &&\r\n          typeof lexer.JisonLexerError === \"function\" &&\r\n          ex instanceof lexer.JisonLexerError\r\n        ) {\r\n          throw ex;\r\n        }\r\n\r\n        p = this.constructParseErrorInfo(\r\n          \"Parsing aborted due to exception.\",\r\n          ex,\r\n          null,\r\n          false\r\n        );\r\n        retval = false;\r\n        r = this.parseError(p.errStr, p, this.JisonParserError);\r\n        if (typeof r !== \"undefined\") {\r\n          retval = r;\r\n        }\r\n      } finally {\r\n        retval = this.cleanupAfterParse(retval, true, true);\r\n        this.__reentrant_call_depth--;\r\n      } // /finally\r\n\r\n      return retval;\r\n    },\r\n  };\r\n  parser.originalParseError = parser.parseError;\r\n  parser.originalQuoteName = parser.quoteName;\r\n  /* lexer generated by jison-lex 0.6.1-215 */\r\n\r\n  /*\r\n   * Returns a Lexer object of the following structure:\r\n   *\r\n   *  Lexer: {\r\n   *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\r\n   *               the real \"shared state\" `yy` passed around to\r\n   *               the rule actions, etc. is a direct reference!\r\n   *\r\n   *               This \"shared context\" object was passed to the lexer by way of\r\n   *               the `lexer.setInput(str, yy)` API before you may use it.\r\n   *\r\n   *               This \"shared context\" object is passed to the lexer action code in `performAction()`\r\n   *               so userland code in the lexer actions may communicate with the outside world\r\n   *               and/or other lexer rules' actions in more or less complex ways.\r\n   *\r\n   *  }\r\n   *\r\n   *  Lexer.prototype: {\r\n   *    EOF: 1,\r\n   *    ERROR: 2,\r\n   *\r\n   *    yy:        The overall \"shared context\" object reference.\r\n   *\r\n   *    JisonLexerError: function(msg, hash),\r\n   *\r\n   *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\r\n   *\r\n   *               The function parameters and `this` have the following value/meaning:\r\n   *               - `this`    : reference to the `lexer` instance.\r\n   *                               `yy_` is an alias for `this` lexer instance reference used internally.\r\n   *\r\n   *               - `yy`      : a reference to the `yy` \"shared state\" object which was passed to the lexer\r\n   *                             by way of the `lexer.setInput(str, yy)` API before.\r\n   *\r\n   *                             Note:\r\n   *                             The extra arguments you specified in the `%parse-param` statement in your\r\n   *                             **parser** grammar definition file are passed to the lexer via this object\r\n   *                             reference as member variables.\r\n   *\r\n   *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\r\n   *\r\n   *               - `YY_START`: the current lexer \"start condition\" state.\r\n   *\r\n   *    parseError: function(str, hash, ExceptionClass),\r\n   *\r\n   *    constructLexErrorInfo: function(error_message, is_recoverable),\r\n   *               Helper function.\r\n   *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\r\n   *               See it's use in this lexer kernel in many places; example usage:\r\n   *\r\n   *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);\r\n   *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\r\n   *\r\n   *    options: { ... lexer %options ... },\r\n   *\r\n   *    lex: function(),\r\n   *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\r\n   *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\r\n   *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\r\n   *\r\n   *               WARNING:\r\n   *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with\r\n   *               any attributes already added to `yy` by the **parser** or the jison run-time;\r\n   *               when such a collision is detected an exception is thrown to prevent the generated run-time\r\n   *               from silently accepting this confusing and potentially hazardous situation!\r\n   *\r\n   *    cleanupAfterLex: function(do_not_nuke_errorinfos),\r\n   *               Helper function.\r\n   *\r\n   *               This helper API is invoked when the **parse process** has completed: it is the responsibility\r\n   *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired.\r\n   *\r\n   *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\r\n   *\r\n   *    setInput: function(input, [yy]),\r\n   *\r\n   *\r\n   *    input: function(),\r\n   *\r\n   *\r\n   *    unput: function(str),\r\n   *\r\n   *\r\n   *    more: function(),\r\n   *\r\n   *\r\n   *    reject: function(),\r\n   *\r\n   *\r\n   *    less: function(n),\r\n   *\r\n   *\r\n   *    pastInput: function(n),\r\n   *\r\n   *\r\n   *    upcomingInput: function(n),\r\n   *\r\n   *\r\n   *    showPosition: function(),\r\n   *\r\n   *\r\n   *    test_match: function(regex_match_array, rule_index),\r\n   *\r\n   *\r\n   *    next: function(),\r\n   *\r\n   *\r\n   *    begin: function(condition),\r\n   *\r\n   *\r\n   *    pushState: function(condition),\r\n   *\r\n   *\r\n   *    popState: function(),\r\n   *\r\n   *\r\n   *    topState: function(),\r\n   *\r\n   *\r\n   *    _currentRules: function(),\r\n   *\r\n   *\r\n   *    stateStackSize: function(),\r\n   *\r\n   *\r\n   *    performAction: function(yy, yy_, yyrulenumber, YY_START),\r\n   *\r\n   *\r\n   *    rules: [...],\r\n   *\r\n   *\r\n   *    conditions: {associative list: name ==> set},\r\n   *  }\r\n   *\r\n   *\r\n   *  token location info (`yylloc`): {\r\n   *    first_line: n,\r\n   *    last_line: n,\r\n   *    first_column: n,\r\n   *    last_column: n,\r\n   *    range: [start_number, end_number]\r\n   *               (where the numbers are indexes into the input string, zero-based)\r\n   *  }\r\n   *\r\n   * ---\r\n   *\r\n   * The `parseError` function receives a 'hash' object with these members for lexer errors:\r\n   *\r\n   *  {\r\n   *    text:        (matched text)\r\n   *    token:       (the produced terminal token, if any)\r\n   *    token_id:    (the produced terminal token numeric ID, if any)\r\n   *    line:        (yylineno)\r\n   *    loc:         (yylloc)\r\n   *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\r\n   *                  available for this particular error)\r\n   *    yy:          (object: the current parser internal \"shared state\" `yy`\r\n   *                  as is also available in the rule actions; this can be used,\r\n   *                  for instance, for advanced error analysis and reporting)\r\n   *    lexer:       (reference to the current lexer instance used by the parser)\r\n   *  }\r\n   *\r\n   * while `this` will reference the current lexer instance.\r\n   *\r\n   * When `parseError` is invoked by the lexer, the default implementation will\r\n   * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\r\n   * it will try to invoke `yy.parseError()` instead. When that callback is also not\r\n   * provided, a `JisonLexerError` exception will be thrown containing the error\r\n   * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\r\n   *\r\n   * Note that the lexer's `JisonLexerError` error class is passed via the\r\n   * `ExceptionClass` argument, which is invoked to construct the exception\r\n   * instance to be thrown, so technically `parseError` will throw the object\r\n   * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\r\n   *\r\n   * ---\r\n   *\r\n   * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\r\n   * These options are available:\r\n   *\r\n   * (Options are permanent.)\r\n   *\r\n   *  yy: {\r\n   *      parseError: function(str, hash, ExceptionClass)\r\n   *                 optional: overrides the default `parseError` function.\r\n   *  }\r\n   *\r\n   *  lexer.options: {\r\n   *      pre_lex:  function()\r\n   *                 optional: is invoked before the lexer is invoked to produce another token.\r\n   *                 `this` refers to the Lexer object.\r\n   *      post_lex: function(token) { return token; }\r\n   *                 optional: is invoked when the lexer has produced a token `token`;\r\n   *                 this function can override the returned token value by returning another.\r\n   *                 When it does not return any (truthy) value, the lexer will return\r\n   *                 the original `token`.\r\n   *                 `this` refers to the Lexer object.\r\n   *\r\n   * WARNING: the next set of options are not meant to be changed. They echo the abilities of\r\n   * the lexer as per when it was compiled!\r\n   *\r\n   *      ranges: boolean\r\n   *                 optional: `true` ==> token location info will include a .range[] member.\r\n   *      flex: boolean\r\n   *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\r\n   *                 exhaustively to find the longest match.\r\n   *      backtrack_lexer: boolean\r\n   *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\r\n   *                 the lexer terminates the scan when a token is returned by the action code.\r\n   *      xregexp: boolean\r\n   *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\r\n   *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\r\n   *                 rule regexes have been written as standard JavaScript RegExp expressions.\r\n   *  }\r\n   */\r\n\r\n  var lexer = (function () {\r\n    /**\r\n     * See also:\r\n     * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\r\n     * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\r\n     * with userland code which might access the derived class in a 'classic' way.\r\n     *\r\n     * @public\r\n     * @constructor\r\n     * @nocollapse\r\n     */\r\n    function JisonLexerError(msg, hash) {\r\n      Object.defineProperty(this, \"name\", {\r\n        enumerable: false,\r\n        writable: false,\r\n        value: \"JisonLexerError\",\r\n      });\r\n\r\n      if (msg == null) msg = \"???\";\r\n\r\n      Object.defineProperty(this, \"message\", {\r\n        enumerable: false,\r\n        writable: true,\r\n        value: msg,\r\n      });\r\n\r\n      this.hash = hash;\r\n      var stacktrace;\r\n\r\n      if (hash && hash.exception instanceof Error) {\r\n        var ex2 = hash.exception;\r\n        this.message = ex2.message || msg;\r\n        stacktrace = ex2.stack;\r\n      }\r\n\r\n      if (!stacktrace) {\r\n        if (Error.hasOwnProperty(\"captureStackTrace\")) {\r\n          // V8\r\n          Error.captureStackTrace(this, this.constructor);\r\n        } else {\r\n          stacktrace = new Error(msg).stack;\r\n        }\r\n      }\r\n\r\n      if (stacktrace) {\r\n        Object.defineProperty(this, \"stack\", {\r\n          enumerable: false,\r\n          writable: false,\r\n          value: stacktrace,\r\n        });\r\n      }\r\n    }\r\n\r\n    if (typeof Object.setPrototypeOf === \"function\") {\r\n      Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\r\n    } else {\r\n      JisonLexerError.prototype = Object.create(Error.prototype);\r\n    }\r\n\r\n    JisonLexerError.prototype.constructor = JisonLexerError;\r\n    JisonLexerError.prototype.name = \"JisonLexerError\";\r\n\r\n    var lexer = {\r\n      // Code Generator Information Report\r\n      // ---------------------------------\r\n      //\r\n      // Options:\r\n      //\r\n      //   backtracking: .................... false\r\n      //   location.ranges: ................. false\r\n      //   location line+column tracking: ... true\r\n      //\r\n      //\r\n      // Forwarded Parser Analysis flags:\r\n      //\r\n      //   uses yyleng: ..................... false\r\n      //   uses yylineno: ................... false\r\n      //   uses yytext: ..................... false\r\n      //   uses yylloc: ..................... false\r\n      //   uses lexer values: ............... true / true\r\n      //   location tracking: ............... false\r\n      //   location assignment: ............. false\r\n      //\r\n      //\r\n      // Lexer Analysis flags:\r\n      //\r\n      //   uses yyleng: ..................... ???\r\n      //   uses yylineno: ................... ???\r\n      //   uses yytext: ..................... ???\r\n      //   uses yylloc: ..................... ???\r\n      //   uses ParseError API: ............. ???\r\n      //   uses yyerror: .................... ???\r\n      //   uses location tracking & editing:  ???\r\n      //   uses more() API: ................. ???\r\n      //   uses unput() API: ................ ???\r\n      //   uses reject() API: ............... ???\r\n      //   uses less() API: ................. ???\r\n      //   uses display APIs pastInput(), upcomingInput(), showPosition():\r\n      //        ............................. ???\r\n      //   uses describeYYLLOC() API: ....... ???\r\n      //\r\n      // --------- END OF REPORT -----------\r\n\r\n      EOF: 1,\r\n      ERROR: 2,\r\n\r\n      // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\r\n\r\n      // options: {},                             /// <-- injected by the code generator\r\n\r\n      // yy: ...,                                 /// <-- injected by setInput()\r\n\r\n      __currentRuleSet__: null, /// INTERNAL USE ONLY: internal rule set cache for the current lexer state\r\n\r\n      __error_infos: [], /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup\r\n      __decompressed: false, /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use\r\n      done: false, /// INTERNAL USE ONLY\r\n      _backtrack: false, /// INTERNAL USE ONLY\r\n      _input: \"\", /// INTERNAL USE ONLY\r\n      _more: false, /// INTERNAL USE ONLY\r\n      _signaled_error_token: false, /// INTERNAL USE ONLY\r\n      conditionStack: [], /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`\r\n      match: \"\", /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!\r\n      matched: \"\", /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far\r\n      matches: false, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt\r\n      yytext: \"\", /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.\r\n      offset: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far\r\n      yyleng: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)\r\n      yylineno: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located\r\n      yylloc: null, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction\r\n\r\n      /**\r\n       * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      constructLexErrorInfo: function lexer_constructLexErrorInfo(\r\n        msg,\r\n        recoverable,\r\n        show_input_position\r\n      ) {\r\n        msg = \"\" + msg;\r\n\r\n        // heuristic to determine if the error message already contains a (partial) source code dump\r\n        // as produced by either `showPosition()` or `prettyPrintRange()`:\r\n        if (show_input_position == undefined) {\r\n          show_input_position = !(\r\n            msg.indexOf(\"\\n\") > 0 && msg.indexOf(\"^\") > 0\r\n          );\r\n        }\r\n\r\n        if (this.yylloc && show_input_position) {\r\n          if (typeof this.prettyPrintRange === \"function\") {\r\n            var pretty_src = this.prettyPrintRange(this.yylloc);\r\n\r\n            if (!/\\n\\s*$/.test(msg)) {\r\n              msg += \"\\n\";\r\n            }\r\n\r\n            msg += \"\\n  Erroneous area:\\n\" + this.prettyPrintRange(this.yylloc);\r\n          } else if (typeof this.showPosition === \"function\") {\r\n            var pos_str = this.showPosition();\r\n\r\n            if (pos_str) {\r\n              if (\r\n                msg.length &&\r\n                msg[msg.length - 1] !== \"\\n\" &&\r\n                pos_str[0] !== \"\\n\"\r\n              ) {\r\n                msg += \"\\n\" + pos_str;\r\n              } else {\r\n                msg += pos_str;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        /** @constructor */\r\n        var pei = {\r\n          errStr: msg,\r\n          recoverable: !!recoverable,\r\n          text: this.match, // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...\r\n          token: null,\r\n          line: this.yylineno,\r\n          loc: this.yylloc,\r\n          yy: this.yy,\r\n          lexer: this,\r\n\r\n          /**\r\n           * and make sure the error info doesn't stay due to potential\r\n           * ref cycle via userland code manipulations.\r\n           * These would otherwise all be memory leak opportunities!\r\n           *\r\n           * Note that only array and object references are nuked as those\r\n           * constitute the set of elements which can produce a cyclic ref.\r\n           * The rest of the members is kept intact as they are harmless.\r\n           *\r\n           * @public\r\n           * @this {LexErrorInfo}\r\n           */\r\n          destroy: function destructLexErrorInfo() {\r\n            // remove cyclic references added to error info:\r\n            // info.yy = null;\r\n            // info.lexer = null;\r\n            // ...\r\n            var rec = !!this.recoverable;\r\n\r\n            for (var key in this) {\r\n              if (this.hasOwnProperty(key) && typeof key === \"object\") {\r\n                this[key] = undefined;\r\n              }\r\n            }\r\n\r\n            this.recoverable = rec;\r\n          },\r\n        };\r\n\r\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\r\n        this.__error_infos.push(pei);\r\n\r\n        return pei;\r\n      },\r\n\r\n      /**\r\n       * handler which is invoked when a lexer error occurs.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      parseError: function lexer_parseError(str, hash, ExceptionClass) {\r\n        if (!ExceptionClass) {\r\n          ExceptionClass = this.JisonLexerError;\r\n        }\r\n\r\n        if (this.yy) {\r\n          if (\r\n            this.yy.parser &&\r\n            typeof this.yy.parser.parseError === \"function\"\r\n          ) {\r\n            return (\r\n              this.yy.parser.parseError.call(this, str, hash, ExceptionClass) ||\r\n              this.ERROR\r\n            );\r\n          } else if (typeof this.yy.parseError === \"function\") {\r\n            return (\r\n              this.yy.parseError.call(this, str, hash, ExceptionClass) ||\r\n              this.ERROR\r\n            );\r\n          }\r\n        }\r\n\r\n        throw new ExceptionClass(str, hash);\r\n      },\r\n\r\n      /**\r\n       * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      yyerror: function yyError(str /*, ...args */) {\r\n        var lineno_msg = \"\";\r\n\r\n        if (this.yylloc) {\r\n          lineno_msg = \" on line \" + (this.yylineno + 1);\r\n        }\r\n\r\n        var p = this.constructLexErrorInfo(\r\n          \"Lexical error\" + lineno_msg + \": \" + str,\r\n          this.options.lexerErrorsAreRecoverable\r\n        );\r\n\r\n        // Add any extra args to the hash under the name `extra_error_attributes`:\r\n        var args = Array.prototype.slice.call(arguments, 1);\r\n\r\n        if (args.length) {\r\n          p.extra_error_attributes = args;\r\n        }\r\n\r\n        return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\r\n      },\r\n\r\n      /**\r\n       * final cleanup function for when we have completed lexing the input;\r\n       * make it an API so that external code can use this one once userland\r\n       * code has decided it's time to destroy any lingering lexer error\r\n       * hash object instances and the like: this function helps to clean\r\n       * up these constructs, which *may* carry cyclic references which would\r\n       * otherwise prevent the instances from being properly and timely\r\n       * garbage-collected, i.e. this function helps prevent memory leaks!\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\r\n        // prevent lingering circular references from causing memory leaks:\r\n        this.setInput(\"\", {});\r\n\r\n        // nuke the error hash info instances created during this run.\r\n        // Userland code must COPY any data/references\r\n        // in the error hash instance(s) it is more permanently interested in.\r\n        if (!do_not_nuke_errorinfos) {\r\n          for (var i = this.__error_infos.length - 1; i >= 0; i--) {\r\n            var el = this.__error_infos[i];\r\n\r\n            if (el && typeof el.destroy === \"function\") {\r\n              el.destroy();\r\n            }\r\n          }\r\n\r\n          this.__error_infos.length = 0;\r\n        }\r\n\r\n        return this;\r\n      },\r\n\r\n      /**\r\n       * clear the lexer token context; intended for internal use only\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      clear: function lexer_clear() {\r\n        this.yytext = \"\";\r\n        this.yyleng = 0;\r\n        this.match = \"\";\r\n\r\n        // - DO NOT reset `this.matched`\r\n        this.matches = false;\r\n\r\n        this._more = false;\r\n        this._backtrack = false;\r\n        var col = this.yylloc ? this.yylloc.last_column : 0;\r\n\r\n        this.yylloc = {\r\n          first_line: this.yylineno + 1,\r\n          first_column: col,\r\n          last_line: this.yylineno + 1,\r\n          last_column: col,\r\n          range: [this.offset, this.offset],\r\n        };\r\n      },\r\n\r\n      /**\r\n       * resets the lexer, sets new input\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      setInput: function lexer_setInput(input, yy) {\r\n        this.yy = yy || this.yy || {};\r\n\r\n        // also check if we've fully initialized the lexer instance,\r\n        // including expansion work to be done to go from a loaded\r\n        // lexer to a usable lexer:\r\n        if (!this.__decompressed) {\r\n          // step 1: decompress the regex list:\r\n          var rules = this.rules;\r\n\r\n          for (var i = 0, len = rules.length; i < len; i++) {\r\n            var rule_re = rules[i];\r\n\r\n            // compression: is the RE an xref to another RE slot in the rules[] table?\r\n            if (typeof rule_re === \"number\") {\r\n              rules[i] = rules[rule_re];\r\n            }\r\n          }\r\n\r\n          // step 2: unfold the conditions[] set to make these ready for use:\r\n          var conditions = this.conditions;\r\n\r\n          for (var k in conditions) {\r\n            var spec = conditions[k];\r\n            var rule_ids = spec.rules;\r\n            var len = rule_ids.length;\r\n            var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple!\r\n            var rule_new_ids = new Array(len + 1);\r\n\r\n            for (var i = 0; i < len; i++) {\r\n              var idx = rule_ids[i];\r\n              var rule_re = rules[idx];\r\n              rule_regexes[i + 1] = rule_re;\r\n              rule_new_ids[i + 1] = idx;\r\n            }\r\n\r\n            spec.rules = rule_new_ids;\r\n            spec.__rule_regexes = rule_regexes;\r\n            spec.__rule_count = len;\r\n          }\r\n\r\n          this.__decompressed = true;\r\n        }\r\n\r\n        this._input = input || \"\";\r\n        this.clear();\r\n        this._signaled_error_token = false;\r\n        this.done = false;\r\n        this.yylineno = 0;\r\n        this.matched = \"\";\r\n        this.conditionStack = [\"INITIAL\"];\r\n        this.__currentRuleSet__ = null;\r\n\r\n        this.yylloc = {\r\n          first_line: 1,\r\n          first_column: 0,\r\n          last_line: 1,\r\n          last_column: 0,\r\n          range: [0, 0],\r\n        };\r\n\r\n        this.offset = 0;\r\n        return this;\r\n      },\r\n\r\n      /**\r\n       * edit the remaining input via user-specified callback.\r\n       * This can be used to forward-adjust the input-to-parse,\r\n       * e.g. inserting macro expansions and alike in the\r\n       * input which has yet to be lexed.\r\n       * The behaviour of this API contrasts the `unput()` et al\r\n       * APIs as those act on the *consumed* input, while this\r\n       * one allows one to manipulate the future, without impacting\r\n       * the current `yyloc` cursor location or any history.\r\n       *\r\n       * Use this API to help implement C-preprocessor-like\r\n       * `#include` statements, etc.\r\n       *\r\n       * The provided callback must be synchronous and is\r\n       * expected to return the edited input (string).\r\n       *\r\n       * The `cpsArg` argument value is passed to the callback\r\n       * as-is.\r\n       *\r\n       * `callback` interface:\r\n       * `function callback(input, cpsArg)`\r\n       *\r\n       * - `input` will carry the remaining-input-to-lex string\r\n       *   from the lexer.\r\n       * - `cpsArg` is `cpsArg` passed into this API.\r\n       *\r\n       * The `this` reference for the callback will be set to\r\n       * reference this lexer instance so that userland code\r\n       * in the callback can easily and quickly access any lexer\r\n       * API.\r\n       *\r\n       * When the callback returns a non-string-type falsey value,\r\n       * we assume the callback did not edit the input and we\r\n       * will using the input as-is.\r\n       *\r\n       * When the callback returns a non-string-type value, it\r\n       * is converted to a string for lexing via the `\"\" + retval`\r\n       * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html\r\n       * -- that way any returned object's `toValue()` and `toString()`\r\n       * methods will be invoked in a proper/desirable order.)\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\r\n        var rv = callback.call(this, this._input, cpsArg);\r\n\r\n        if (typeof rv !== \"string\") {\r\n          if (rv) {\r\n            this._input = \"\" + rv;\r\n          }\r\n          // else: keep `this._input` as is.\r\n        } else {\r\n          this._input = rv;\r\n        }\r\n\r\n        return this;\r\n      },\r\n\r\n      /**\r\n       * consumes and returns one char from the input\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      input: function lexer_input() {\r\n        if (!this._input) {\r\n          //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\r\n          return null;\r\n        }\r\n\r\n        var ch = this._input[0];\r\n        this.yytext += ch;\r\n        this.yyleng++;\r\n        this.offset++;\r\n        this.match += ch;\r\n        this.matched += ch;\r\n\r\n        // Count the linenumber up when we hit the LF (or a stand-alone CR).\r\n        // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\r\n        // and we advance immediately past the LF as well, returning both together as if\r\n        // it was all a single 'character' only.\r\n        var slice_len = 1;\r\n\r\n        var lines = false;\r\n\r\n        if (ch === \"\\n\") {\r\n          lines = true;\r\n        } else if (ch === \"\\r\") {\r\n          lines = true;\r\n          var ch2 = this._input[1];\r\n\r\n          if (ch2 === \"\\n\") {\r\n            slice_len++;\r\n            ch += ch2;\r\n            this.yytext += ch2;\r\n            this.yyleng++;\r\n            this.offset++;\r\n            this.match += ch2;\r\n            this.matched += ch2;\r\n            this.yylloc.range[1]++;\r\n          }\r\n        }\r\n\r\n        if (lines) {\r\n          this.yylineno++;\r\n          this.yylloc.last_line++;\r\n          this.yylloc.last_column = 0;\r\n        } else {\r\n          this.yylloc.last_column++;\r\n        }\r\n\r\n        this.yylloc.range[1]++;\r\n        this._input = this._input.slice(slice_len);\r\n        return ch;\r\n      },\r\n\r\n      /**\r\n       * unshifts one char (or an entire string) into the input\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      unput: function lexer_unput(ch) {\r\n        var len = ch.length;\r\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n        this._input = ch + this._input;\r\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n        this.yyleng = this.yytext.length;\r\n        this.offset -= len;\r\n        this.match = this.match.substr(0, this.match.length - len);\r\n        this.matched = this.matched.substr(0, this.matched.length - len);\r\n\r\n        if (lines.length > 1) {\r\n          this.yylineno -= lines.length - 1;\r\n          this.yylloc.last_line = this.yylineno + 1;\r\n\r\n          // Get last entirely matched line into the `pre_lines[]` array's\r\n          // last index slot; we don't mind when other previously\r\n          // matched lines end up in the array too.\r\n          var pre = this.match;\r\n\r\n          var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\r\n\r\n          if (pre_lines.length === 1) {\r\n            pre = this.matched;\r\n            pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\r\n          }\r\n\r\n          this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\r\n        } else {\r\n          this.yylloc.last_column -= len;\r\n        }\r\n\r\n        this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\r\n        this.done = false;\r\n        return this;\r\n      },\r\n\r\n      /**\r\n       * cache matched text and append it on next action\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      more: function lexer_more() {\r\n        this._more = true;\r\n        return this;\r\n      },\r\n\r\n      /**\r\n       * signal the lexer that this rule fails to match the input, so the\r\n       * next matching rule (regex) should be tested instead.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      reject: function lexer_reject() {\r\n        if (this.options.backtrack_lexer) {\r\n          this._backtrack = true;\r\n        } else {\r\n          // when the `parseError()` call returns, we MUST ensure that the error is registered.\r\n          // We accomplish this by signaling an 'error' token to be produced for the current\r\n          // `.lex()` run.\r\n          var lineno_msg = \"\";\r\n\r\n          if (this.yylloc) {\r\n            lineno_msg = \" on line \" + (this.yylineno + 1);\r\n          }\r\n\r\n          var p = this.constructLexErrorInfo(\r\n            \"Lexical error\" +\r\n              lineno_msg +\r\n              \": You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\",\r\n            false\r\n          );\r\n\r\n          this._signaled_error_token =\r\n            this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\r\n        }\r\n\r\n        return this;\r\n      },\r\n\r\n      /**\r\n       * retain first n characters of the match\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      less: function lexer_less(n) {\r\n        return this.unput(this.match.slice(n));\r\n      },\r\n\r\n      /**\r\n       * return (part of the) already matched input, i.e. for error\r\n       * messages.\r\n       *\r\n       * Limit the returned string length to `maxSize` (default: 20).\r\n       *\r\n       * Limit the returned string to the `maxLines` number of lines of\r\n       * input (default: 1).\r\n       *\r\n       * Negative limit values equal *unlimited*.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      pastInput: function lexer_pastInput(maxSize, maxLines) {\r\n        var past = this.matched.substring(\r\n          0,\r\n          this.matched.length - this.match.length\r\n        );\r\n\r\n        if (maxSize < 0) maxSize = past.length;\r\n        else if (!maxSize) maxSize = 20;\r\n\r\n        if (maxLines < 0)\r\n          maxLines = past.length; // can't ever have more input lines than this!\r\n        else if (!maxLines) maxLines = 1;\r\n\r\n        // `substr` anticipation: treat \\r\\n as a single character and take a little\r\n        // more than necessary so that we can still properly check against maxSize\r\n        // after we've transformed and limited the newLines in here:\r\n        past = past.substr(-maxSize * 2 - 2);\r\n\r\n        // now that we have a significantly reduced string to process, transform the newlines\r\n        // and chop them, then limit them:\r\n        var a = past.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\r\n\r\n        a = a.slice(-maxLines);\r\n        past = a.join(\"\\n\");\r\n\r\n        // When, after limiting to maxLines, we still have too much to return,\r\n        // do add an ellipsis prefix...\r\n        if (past.length > maxSize) {\r\n          past = \"...\" + past.substr(-maxSize);\r\n        }\r\n\r\n        return past;\r\n      },\r\n\r\n      /**\r\n       * return (part of the) upcoming input, i.e. for error messages.\r\n       *\r\n       * Limit the returned string length to `maxSize` (default: 20).\r\n       *\r\n       * Limit the returned string to the `maxLines` number of lines of input (default: 1).\r\n       *\r\n       * Negative limit values equal *unlimited*.\r\n       *\r\n       * > ### NOTE ###\r\n       * >\r\n       * > *\"upcoming input\"* is defined as the whole of the both\r\n       * > the *currently lexed* input, together with any remaining input\r\n       * > following that. *\"currently lexed\"* input is the input\r\n       * > already recognized by the lexer but not yet returned with\r\n       * > the lexer token. This happens when you are invoking this API\r\n       * > from inside any lexer rule action code block.\r\n       * >\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\r\n        var next = this.match;\r\n\r\n        if (maxSize < 0) maxSize = next.length + this._input.length;\r\n        else if (!maxSize) maxSize = 20;\r\n\r\n        if (maxLines < 0)\r\n          maxLines = maxSize; // can't ever have more input lines than this!\r\n        else if (!maxLines) maxLines = 1;\r\n\r\n        // `substring` anticipation: treat \\r\\n as a single character and take a little\r\n        // more than necessary so that we can still properly check against maxSize\r\n        // after we've transformed and limited the newLines in here:\r\n        if (next.length < maxSize * 2 + 2) {\r\n          next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8\r\n        }\r\n\r\n        // now that we have a significantly reduced string to process, transform the newlines\r\n        // and chop them, then limit them:\r\n        var a = next.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\r\n\r\n        a = a.slice(0, maxLines);\r\n        next = a.join(\"\\n\");\r\n\r\n        // When, after limiting to maxLines, we still have too much to return,\r\n        // do add an ellipsis postfix...\r\n        if (next.length > maxSize) {\r\n          next = next.substring(0, maxSize) + \"...\";\r\n        }\r\n\r\n        return next;\r\n      },\r\n\r\n      /**\r\n       * return a string which displays the character position where the\r\n       * lexing error occurred, i.e. for error messages\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\r\n        var pre = this.pastInput(maxPrefix).replace(/\\s/g, \" \");\r\n        var c = new Array(pre.length + 1).join(\"-\");\r\n        return (\r\n          pre +\r\n          this.upcomingInput(maxPostfix).replace(/\\s/g, \" \") +\r\n          \"\\n\" +\r\n          c +\r\n          \"^\"\r\n        );\r\n      },\r\n\r\n      /**\r\n       * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\r\n       * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\r\n       * it MAY be NULL) and you MUST have a valid location info object anyway:\r\n       * then we take the given context of the `preceding` and `following` locations, IFF those are available,\r\n       * and reconstruct the `actual` location info from those.\r\n       * If this fails, the heuristic is to take the `current` location, IFF available.\r\n       * If this fails as well, we assume the sought location is at/around the current lexer position\r\n       * and then produce that one as a response. DO NOTE that these heuristic/derived location info\r\n       * values MAY be inaccurate!\r\n       *\r\n       * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\r\n       * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      deriveLocationInfo: function lexer_deriveYYLLOC(\r\n        actual,\r\n        preceding,\r\n        following,\r\n        current\r\n      ) {\r\n        var loc = {\r\n          first_line: 1,\r\n          first_column: 0,\r\n          last_line: 1,\r\n          last_column: 0,\r\n          range: [0, 0],\r\n        };\r\n\r\n        if (actual) {\r\n          loc.first_line = actual.first_line | 0;\r\n          loc.last_line = actual.last_line | 0;\r\n          loc.first_column = actual.first_column | 0;\r\n          loc.last_column = actual.last_column | 0;\r\n\r\n          if (actual.range) {\r\n            loc.range[0] = actual.range[0] | 0;\r\n            loc.range[1] = actual.range[1] | 0;\r\n          }\r\n        }\r\n\r\n        if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\r\n          // plan B: heuristic using preceding and following:\r\n          if (loc.first_line <= 0 && preceding) {\r\n            loc.first_line = preceding.last_line | 0;\r\n            loc.first_column = preceding.last_column | 0;\r\n\r\n            if (preceding.range) {\r\n              loc.range[0] = actual.range[1] | 0;\r\n            }\r\n          }\r\n\r\n          if (\r\n            (loc.last_line <= 0 || loc.last_line < loc.first_line) &&\r\n            following\r\n          ) {\r\n            loc.last_line = following.first_line | 0;\r\n            loc.last_column = following.first_column | 0;\r\n\r\n            if (following.range) {\r\n              loc.range[1] = actual.range[0] | 0;\r\n            }\r\n          }\r\n\r\n          // plan C?: see if the 'current' location is useful/sane too:\r\n          if (\r\n            loc.first_line <= 0 &&\r\n            current &&\r\n            (loc.last_line <= 0 || current.last_line <= loc.last_line)\r\n          ) {\r\n            loc.first_line = current.first_line | 0;\r\n            loc.first_column = current.first_column | 0;\r\n\r\n            if (current.range) {\r\n              loc.range[0] = current.range[0] | 0;\r\n            }\r\n          }\r\n\r\n          if (\r\n            loc.last_line <= 0 &&\r\n            current &&\r\n            (loc.first_line <= 0 || current.first_line >= loc.first_line)\r\n          ) {\r\n            loc.last_line = current.last_line | 0;\r\n            loc.last_column = current.last_column | 0;\r\n\r\n            if (current.range) {\r\n              loc.range[1] = current.range[1] | 0;\r\n            }\r\n          }\r\n        }\r\n\r\n        // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter\r\n        // or plan D heuristics to produce a 'sensible' last_line value:\r\n        if (loc.last_line <= 0) {\r\n          if (loc.first_line <= 0) {\r\n            loc.first_line = this.yylloc.first_line;\r\n            loc.last_line = this.yylloc.last_line;\r\n            loc.first_column = this.yylloc.first_column;\r\n            loc.last_column = this.yylloc.last_column;\r\n            loc.range[0] = this.yylloc.range[0];\r\n            loc.range[1] = this.yylloc.range[1];\r\n          } else {\r\n            loc.last_line = this.yylloc.last_line;\r\n            loc.last_column = this.yylloc.last_column;\r\n            loc.range[1] = this.yylloc.range[1];\r\n          }\r\n        }\r\n\r\n        if (loc.first_line <= 0) {\r\n          loc.first_line = loc.last_line;\r\n          loc.first_column = 0; // loc.last_column;\r\n          loc.range[1] = loc.range[0];\r\n        }\r\n\r\n        if (loc.first_column < 0) {\r\n          loc.first_column = 0;\r\n        }\r\n\r\n        if (loc.last_column < 0) {\r\n          loc.last_column = loc.first_column > 0 ? loc.first_column : 80;\r\n        }\r\n\r\n        return loc;\r\n      },\r\n\r\n      /**\r\n       * return a string which displays the lines & columns of input which are referenced\r\n       * by the given location info range, plus a few lines of context.\r\n       *\r\n       * This function pretty-prints the indicated section of the input, with line numbers\r\n       * and everything!\r\n       *\r\n       * This function is very useful to provide highly readable error reports, while\r\n       * the location range may be specified in various flexible ways:\r\n       *\r\n       * - `loc` is the location info object which references the area which should be\r\n       *   displayed and 'marked up': these lines & columns of text are marked up by `^`\r\n       *   characters below each character in the entire input range.\r\n       *\r\n       * - `context_loc` is the *optional* location info object which instructs this\r\n       *   pretty-printer how much *leading* context should be displayed alongside\r\n       *   the area referenced by `loc`. This can help provide context for the displayed\r\n       *   error, etc.\r\n       *\r\n       *   When this location info is not provided, a default context of 3 lines is\r\n       *   used.\r\n       *\r\n       * - `context_loc2` is another *optional* location info object, which serves\r\n       *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\r\n       *   context lines to display in the pretty-print output.\r\n       *\r\n       *   When this location info is not provided, a default context of 1 line only is\r\n       *   used.\r\n       *\r\n       * Special Notes:\r\n       *\r\n       * - when the `loc`-indicated range is very large (about 5 lines or more), then\r\n       *   only the first and last few lines of this block are printed while a\r\n       *   `...continued...` message will be printed between them.\r\n       *\r\n       *   This serves the purpose of not printing a huge amount of text when the `loc`\r\n       *   range happens to be huge: this way a manageable & readable output results\r\n       *   for arbitrary large ranges.\r\n       *\r\n       * - this function can display lines of input which whave not yet been lexed.\r\n       *   `prettyPrintRange()` can access the entire input!\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      prettyPrintRange: function lexer_prettyPrintRange(\r\n        loc,\r\n        context_loc,\r\n        context_loc2\r\n      ) {\r\n        loc = this.deriveLocationInfo(loc, context_loc, context_loc2);\r\n        const CONTEXT = 3;\r\n        const CONTEXT_TAIL = 1;\r\n        const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\r\n        var input = this.matched + this._input;\r\n        var lines = input.split(\"\\n\");\r\n        var l0 = Math.max(\r\n          1,\r\n          context_loc ? context_loc.first_line : loc.first_line - CONTEXT\r\n        );\r\n        var l1 = Math.max(\r\n          1,\r\n          context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL\r\n        );\r\n        var lineno_display_width = (1 + Math.log10(l1 | 1)) | 0;\r\n        var ws_prefix = new Array(lineno_display_width).join(\" \");\r\n        var nonempty_line_indexes = [];\r\n\r\n        var rv = lines\r\n          .slice(l0 - 1, l1 + 1)\r\n          .map(function injectLineNumber(line, index) {\r\n            var lno = index + l0;\r\n            var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\r\n            var rv = lno_pfx + \": \" + line;\r\n            var errpfx = new Array(lineno_display_width + 1).join(\"^\");\r\n            var offset = 2 + 1;\r\n            var len = 0;\r\n\r\n            if (lno === loc.first_line) {\r\n              offset += loc.first_column;\r\n\r\n              len = Math.max(\r\n                2,\r\n                (lno === loc.last_line ? loc.last_column : line.length) -\r\n                  loc.first_column +\r\n                  1\r\n              );\r\n            } else if (lno === loc.last_line) {\r\n              len = Math.max(2, loc.last_column + 1);\r\n            } else if (lno > loc.first_line && lno < loc.last_line) {\r\n              len = Math.max(2, line.length + 1);\r\n            }\r\n\r\n            if (len) {\r\n              var lead = new Array(offset).join(\".\");\r\n              var mark = new Array(len).join(\"^\");\r\n              rv += \"\\n\" + errpfx + lead + mark;\r\n\r\n              if (line.trim().length > 0) {\r\n                nonempty_line_indexes.push(index);\r\n              }\r\n            }\r\n\r\n            rv = rv.replace(/\\t/g, \" \");\r\n            return rv;\r\n          });\r\n\r\n        // now make sure we don't print an overly large amount of error area: limit it\r\n        // to the top and bottom line count:\r\n        if (\r\n          nonempty_line_indexes.length >\r\n          2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT\r\n        ) {\r\n          var clip_start =\r\n            nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\r\n          var clip_end =\r\n            nonempty_line_indexes[\r\n              nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT\r\n            ] - 1;\r\n          var intermediate_line =\r\n            new Array(lineno_display_width + 1).join(\" \") +\r\n            \"  (...continued...)\";\r\n          intermediate_line +=\r\n            \"\\n\" +\r\n            new Array(lineno_display_width + 1).join(\"-\") +\r\n            \"  (---------------)\";\r\n          rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\r\n        }\r\n\r\n        return rv.join(\"\\n\");\r\n      },\r\n\r\n      /**\r\n       * helper function, used to produce a human readable description as a string, given\r\n       * the input `yylloc` location object.\r\n       *\r\n       * Set `display_range_too` to TRUE to include the string character index position(s)\r\n       * in the description if the `yylloc.range` is available.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      describeYYLLOC: function lexer_describe_yylloc(\r\n        yylloc,\r\n        display_range_too\r\n      ) {\r\n        var l1 = yylloc.first_line;\r\n        var l2 = yylloc.last_line;\r\n        var c1 = yylloc.first_column;\r\n        var c2 = yylloc.last_column;\r\n        var dl = l2 - l1;\r\n        var dc = c2 - c1;\r\n        var rv;\r\n\r\n        if (dl === 0) {\r\n          rv = \"line \" + l1 + \", \";\r\n\r\n          if (dc <= 1) {\r\n            rv += \"column \" + c1;\r\n          } else {\r\n            rv += \"columns \" + c1 + \" .. \" + c2;\r\n          }\r\n        } else {\r\n          rv =\r\n            \"lines \" +\r\n            l1 +\r\n            \"(column \" +\r\n            c1 +\r\n            \") .. \" +\r\n            l2 +\r\n            \"(column \" +\r\n            c2 +\r\n            \")\";\r\n        }\r\n\r\n        if (yylloc.range && display_range_too) {\r\n          var r1 = yylloc.range[0];\r\n          var r2 = yylloc.range[1] - 1;\r\n\r\n          if (r2 <= r1) {\r\n            rv += \" {String Offset: \" + r1 + \"}\";\r\n          } else {\r\n            rv += \" {String Offset range: \" + r1 + \" .. \" + r2 + \"}\";\r\n          }\r\n        }\r\n\r\n        return rv;\r\n      },\r\n\r\n      /**\r\n       * test the lexed token: return FALSE when not a match, otherwise return token.\r\n       *\r\n       * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\r\n       * contains the actually matched text string.\r\n       *\r\n       * Also move the input cursor forward and update the match collectors:\r\n       *\r\n       * - `yytext`\r\n       * - `yyleng`\r\n       * - `match`\r\n       * - `matches`\r\n       * - `yylloc`\r\n       * - `offset`\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      test_match: function lexer_test_match(match, indexed_rule) {\r\n        var token, lines, backup, match_str, match_str_len;\r\n\r\n        if (this.options.backtrack_lexer) {\r\n          // save context\r\n          backup = {\r\n            yylineno: this.yylineno,\r\n\r\n            yylloc: {\r\n              first_line: this.yylloc.first_line,\r\n              last_line: this.yylloc.last_line,\r\n              first_column: this.yylloc.first_column,\r\n              last_column: this.yylloc.last_column,\r\n              range: this.yylloc.range.slice(0),\r\n            },\r\n\r\n            yytext: this.yytext,\r\n            match: this.match,\r\n            matches: this.matches,\r\n            matched: this.matched,\r\n            yyleng: this.yyleng,\r\n            offset: this.offset,\r\n            _more: this._more,\r\n            _input: this._input,\r\n\r\n            //_signaled_error_token: this._signaled_error_token,\r\n            yy: this.yy,\r\n\r\n            conditionStack: this.conditionStack.slice(0),\r\n            done: this.done,\r\n          };\r\n        }\r\n\r\n        match_str = match[0];\r\n        match_str_len = match_str.length;\r\n\r\n        // if (match_str.indexOf('\\n') !== -1 || match_str.indexOf('\\r') !== -1) {\r\n        lines = match_str.split(/(?:\\r\\n?|\\n)/g);\r\n\r\n        if (lines.length > 1) {\r\n          this.yylineno += lines.length - 1;\r\n          this.yylloc.last_line = this.yylineno + 1;\r\n          this.yylloc.last_column = lines[lines.length - 1].length;\r\n        } else {\r\n          this.yylloc.last_column += match_str_len;\r\n        }\r\n\r\n        // }\r\n        this.yytext += match_str;\r\n\r\n        this.match += match_str;\r\n        this.matched += match_str;\r\n        this.matches = match;\r\n        this.yyleng = this.yytext.length;\r\n        this.yylloc.range[1] += match_str_len;\r\n\r\n        // previous lex rules MAY have invoked the `more()` API rather than producing a token:\r\n        // those rules will already have moved this `offset` forward matching their match lengths,\r\n        // hence we must only add our own match length now:\r\n        this.offset += match_str_len;\r\n\r\n        this._more = false;\r\n        this._backtrack = false;\r\n        this._input = this._input.slice(match_str_len);\r\n\r\n        // calling this method:\r\n        //\r\n        //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\r\n        token = this.performAction.call(\r\n          this,\r\n          this.yy,\r\n          indexed_rule,\r\n          this.conditionStack[this.conditionStack.length - 1] /* = YY_START */\r\n        );\r\n\r\n        // otherwise, when the action codes are all simple return token statements:\r\n        //token = this.simpleCaseActionClusters[indexed_rule];\r\n\r\n        if (this.done && this._input) {\r\n          this.done = false;\r\n        }\r\n\r\n        if (token) {\r\n          return token;\r\n        } else if (this._backtrack) {\r\n          // recover context\r\n          for (var k in backup) {\r\n            this[k] = backup[k];\r\n          }\r\n\r\n          this.__currentRuleSet__ = null;\r\n          return false; // rule action called reject() implying the next rule should be tested instead.\r\n        } else if (this._signaled_error_token) {\r\n          // produce one 'error' token as `.parseError()` in `reject()`\r\n          // did not guarantee a failure signal by throwing an exception!\r\n          token = this._signaled_error_token;\r\n\r\n          this._signaled_error_token = false;\r\n          return token;\r\n        }\r\n\r\n        return false;\r\n      },\r\n\r\n      /**\r\n       * return next match in input\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      next: function lexer_next() {\r\n        if (this.done) {\r\n          this.clear();\r\n          return this.EOF;\r\n        }\r\n\r\n        if (!this._input) {\r\n          this.done = true;\r\n        }\r\n\r\n        var token, match, tempMatch, index;\r\n\r\n        if (!this._more) {\r\n          this.clear();\r\n        }\r\n\r\n        var spec = this.__currentRuleSet__;\r\n\r\n        if (!spec) {\r\n          // Update the ruleset cache as we apparently encountered a state change or just started lexing.\r\n          // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\r\n          // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\r\n          // speed up those activities a tiny bit.\r\n          spec = this.__currentRuleSet__ = this._currentRules();\r\n\r\n          // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\r\n          // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\r\n          if (!spec || !spec.rules) {\r\n            var lineno_msg = \"\";\r\n\r\n            if (this.options.trackPosition) {\r\n              lineno_msg = \" on line \" + (this.yylineno + 1);\r\n            }\r\n\r\n            var p = this.constructLexErrorInfo(\r\n              \"Internal lexer engine error\" +\r\n                lineno_msg +\r\n                ': The lex grammar programmer pushed a non-existing condition name \"' +\r\n                this.topState() +\r\n                '\"; this is a fatal error and should be reported to the application programmer team!',\r\n              false\r\n            );\r\n\r\n            // produce one 'error' token until this situation has been resolved, most probably by parse termination!\r\n            return (\r\n              this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR\r\n            );\r\n          }\r\n        }\r\n\r\n        var rule_ids = spec.rules;\r\n        var regexes = spec.__rule_regexes;\r\n        var len = spec.__rule_count;\r\n\r\n        // Note: the arrays are 1-based, while `len` itself is a valid index,\r\n        // hence the non-standard less-or-equal check in the next loop condition!\r\n        for (var i = 1; i <= len; i++) {\r\n          tempMatch = this._input.match(regexes[i]);\r\n\r\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n            match = tempMatch;\r\n            index = i;\r\n\r\n            if (this.options.backtrack_lexer) {\r\n              token = this.test_match(tempMatch, rule_ids[i]);\r\n\r\n              if (token !== false) {\r\n                return token;\r\n              } else if (this._backtrack) {\r\n                match = undefined;\r\n                continue; // rule action called reject() implying a rule MISmatch.\r\n              } else {\r\n                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                return false;\r\n              }\r\n            } else if (!this.options.flex) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (match) {\r\n          token = this.test_match(match, rule_ids[index]);\r\n\r\n          if (token !== false) {\r\n            return token;\r\n          }\r\n\r\n          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n          return false;\r\n        }\r\n\r\n        if (!this._input) {\r\n          this.done = true;\r\n          this.clear();\r\n          return this.EOF;\r\n        } else {\r\n          var lineno_msg = \"\";\r\n\r\n          if (this.options.trackPosition) {\r\n            lineno_msg = \" on line \" + (this.yylineno + 1);\r\n          }\r\n\r\n          var p = this.constructLexErrorInfo(\r\n            \"Lexical error\" + lineno_msg + \": Unrecognized text.\",\r\n            this.options.lexerErrorsAreRecoverable\r\n          );\r\n\r\n          var pendingInput = this._input;\r\n          var activeCondition = this.topState();\r\n          var conditionStackDepth = this.conditionStack.length;\r\n          token =\r\n            this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\r\n\r\n          if (token === this.ERROR) {\r\n            // we can try to recover from a lexer error that `parseError()` did not 'recover' for us\r\n            // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\r\n            // has not consumed/modified any pending input or changed state in the error handler:\r\n            if (\r\n              !this.matches && // and make sure the input has been modified/consumed ...\r\n              pendingInput === this._input && // ...or the lexer state has been modified significantly enough\r\n              // to merit a non-consuming error handling action right now.\r\n              activeCondition === this.topState() &&\r\n              conditionStackDepth === this.conditionStack.length\r\n            ) {\r\n              this.input();\r\n            }\r\n          }\r\n\r\n          return token;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * return next match that has a token\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      lex: function lexer_lex() {\r\n        var r;\r\n\r\n        // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\r\n        if (typeof this.pre_lex === \"function\") {\r\n          r = this.pre_lex.call(this, 0);\r\n        }\r\n\r\n        if (typeof this.options.pre_lex === \"function\") {\r\n          // (also account for a userdef function which does not return any value: keep the token as is)\r\n          r = this.options.pre_lex.call(this, r) || r;\r\n        }\r\n\r\n        if (this.yy && typeof this.yy.pre_lex === \"function\") {\r\n          // (also account for a userdef function which does not return any value: keep the token as is)\r\n          r = this.yy.pre_lex.call(this, r) || r;\r\n        }\r\n\r\n        while (!r) {\r\n          r = this.next();\r\n        }\r\n\r\n        if (this.yy && typeof this.yy.post_lex === \"function\") {\r\n          // (also account for a userdef function which does not return any value: keep the token as is)\r\n          r = this.yy.post_lex.call(this, r) || r;\r\n        }\r\n\r\n        if (typeof this.options.post_lex === \"function\") {\r\n          // (also account for a userdef function which does not return any value: keep the token as is)\r\n          r = this.options.post_lex.call(this, r) || r;\r\n        }\r\n\r\n        if (typeof this.post_lex === \"function\") {\r\n          // (also account for a userdef function which does not return any value: keep the token as is)\r\n          r = this.post_lex.call(this, r) || r;\r\n        }\r\n\r\n        return r;\r\n      },\r\n\r\n      /**\r\n       * return next match that has a token. Identical to the `lex()` API but does not invoke any of the\r\n       * `pre_lex()` nor any of the `post_lex()` callbacks.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      fastLex: function lexer_fastLex() {\r\n        var r;\r\n\r\n        while (!r) {\r\n          r = this.next();\r\n        }\r\n\r\n        return r;\r\n      },\r\n\r\n      /**\r\n       * return info about the lexer state that can help a parser or other lexer API user to use the\r\n       * most efficient means available. This API is provided to aid run-time performance for larger\r\n       * systems which employ this lexer.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      canIUse: function lexer_canIUse() {\r\n        var rv = {\r\n          fastLex:\r\n            !(\r\n              typeof this.pre_lex === \"function\" ||\r\n              typeof this.options.pre_lex === \"function\" ||\r\n              (this.yy && typeof this.yy.pre_lex === \"function\") ||\r\n              (this.yy && typeof this.yy.post_lex === \"function\") ||\r\n              typeof this.options.post_lex === \"function\" ||\r\n              typeof this.post_lex === \"function\"\r\n            ) && typeof this.fastLex === \"function\",\r\n        };\r\n\r\n        return rv;\r\n      },\r\n\r\n      /**\r\n       * backwards compatible alias for `pushState()`;\r\n       * the latter is symmetrical with `popState()` and we advise to use\r\n       * those APIs in any modern lexer code, rather than `begin()`.\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      begin: function lexer_begin(condition) {\r\n        return this.pushState(condition);\r\n      },\r\n\r\n      /**\r\n       * activates a new lexer condition state (pushes the new lexer\r\n       * condition state onto the condition stack)\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      pushState: function lexer_pushState(condition) {\r\n        this.conditionStack.push(condition);\r\n        this.__currentRuleSet__ = null;\r\n        return this;\r\n      },\r\n\r\n      /**\r\n       * pop the previously active lexer condition state off the condition\r\n       * stack\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      popState: function lexer_popState() {\r\n        var n = this.conditionStack.length - 1;\r\n\r\n        if (n > 0) {\r\n          this.__currentRuleSet__ = null;\r\n          return this.conditionStack.pop();\r\n        } else {\r\n          return this.conditionStack[0];\r\n        }\r\n      },\r\n\r\n      /**\r\n       * return the currently active lexer condition state; when an index\r\n       * argument is provided it produces the N-th previous condition state,\r\n       * if available\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      topState: function lexer_topState(n) {\r\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n\r\n        if (n >= 0) {\r\n          return this.conditionStack[n];\r\n        } else {\r\n          return \"INITIAL\";\r\n        }\r\n      },\r\n\r\n      /**\r\n       * (internal) determine the lexer rule set which is active for the\r\n       * currently active lexer condition state\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      _currentRules: function lexer__currentRules() {\r\n        if (\r\n          this.conditionStack.length &&\r\n          this.conditionStack[this.conditionStack.length - 1]\r\n        ) {\r\n          return this.conditions[\r\n            this.conditionStack[this.conditionStack.length - 1]\r\n          ];\r\n        } else {\r\n          return this.conditions[\"INITIAL\"];\r\n        }\r\n      },\r\n\r\n      /**\r\n       * return the number of states currently on the stack\r\n       *\r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\r\n      stateStackSize: function lexer_stateStackSize() {\r\n        return this.conditionStack.length;\r\n      },\r\n\r\n      options: {\r\n        trackPosition: true,\r\n      },\r\n\r\n      JisonLexerError: JisonLexerError,\r\n\r\n      performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {\r\n        var yy_ = this;\r\n        var YYSTATE = YY_START;\r\n\r\n        switch (yyrulenumber) {\r\n          case 1:\r\n            /*! Conditions:: INITIAL */\r\n            /*! Rule::       \\s+ */\r\n            /* skip whitespace */\r\n            break;\r\n\r\n          default:\r\n            return this.simpleCaseActionClusters[yyrulenumber];\r\n        }\r\n      },\r\n\r\n      simpleCaseActionClusters: {\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       (--[0-9a-z-A-Z-]*) */\r\n        0: 16,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       \\* */\r\n        2: 5,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       \\/ */\r\n        3: 6,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       \\+ */\r\n        4: 3,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       - */\r\n        5: 4,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)px\\b */\r\n        6: 17,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)cm\\b */\r\n        7: 17,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)mm\\b */\r\n        8: 17,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)in\\b */\r\n        9: 17,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pt\\b */\r\n        10: 17,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pc\\b */\r\n        11: 17,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)deg\\b */\r\n        12: 18,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)grad\\b */\r\n        13: 18,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rad\\b */\r\n        14: 18,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)turn\\b */\r\n        15: 18,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)s\\b */\r\n        16: 19,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ms\\b */\r\n        17: 19,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)Hz\\b */\r\n        18: 20,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)kHz\\b */\r\n        19: 20,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpi\\b */\r\n        20: 21,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpcm\\b */\r\n        21: 21,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dppx\\b */\r\n        22: 21,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)em\\b */\r\n        23: 22,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ex\\b */\r\n        24: 23,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ch\\b */\r\n        25: 24,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rem\\b */\r\n        26: 25,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vw\\b */\r\n        27: 27,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vh\\b */\r\n        28: 26,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmin\\b */\r\n        29: 28,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmax\\b */\r\n        30: 29,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)% */\r\n        31: 30,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)\\b */\r\n        32: 14,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       (calc) */\r\n        33: 9,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       (var) */\r\n        34: 15,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       (max) */\r\n        35: 10,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       (min) */\r\n        36: 12,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       ([a-z]+) */\r\n        37: 13,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       \\( */\r\n        38: 7,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       \\) */\r\n        39: 8,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       , */\r\n        40: 11,\r\n\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       $ */\r\n        41: 1,\r\n      },\r\n\r\n      rules: [\r\n        /*  0: */ /^(?:(--[\\d\\-A-Za-z]*))/,\r\n        /*  1: */ /^(?:\\s+)/,\r\n        /*  2: */ /^(?:\\*)/,\r\n        /*  3: */ /^(?:\\/)/,\r\n        /*  4: */ /^(?:\\+)/,\r\n        /*  5: */ /^(?:-)/,\r\n        /*  6: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)px\\b)/,\r\n        /*  7: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)cm\\b)/,\r\n        /*  8: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)mm\\b)/,\r\n        /*  9: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)in\\b)/,\r\n        /* 10: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pt\\b)/,\r\n        /* 11: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pc\\b)/,\r\n        /* 12: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)deg\\b)/,\r\n        /* 13: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)grad\\b)/,\r\n        /* 14: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rad\\b)/,\r\n        /* 15: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)turn\\b)/,\r\n        /* 16: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)s\\b)/,\r\n        /* 17: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ms\\b)/,\r\n        /* 18: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)Hz\\b)/,\r\n        /* 19: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)kHz\\b)/,\r\n        /* 20: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpi\\b)/,\r\n        /* 21: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpcm\\b)/,\r\n        /* 22: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dppx\\b)/,\r\n        /* 23: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)em\\b)/,\r\n        /* 24: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ex\\b)/,\r\n        /* 25: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ch\\b)/,\r\n        /* 26: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rem\\b)/,\r\n        /* 27: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vw\\b)/,\r\n        /* 28: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vh\\b)/,\r\n        /* 29: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmin\\b)/,\r\n        /* 30: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmax\\b)/,\r\n        /* 31: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)%)/,\r\n        /* 32: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)\\b)/,\r\n        /* 33: */ /^(?:(calc))/,\r\n        /* 34: */ /^(?:(var))/,\r\n        /* 35: */ /^(?:(max))/,\r\n        /* 36: */ /^(?:(min))/,\r\n        /* 37: */ /^(?:([a-z]+))/,\r\n        /* 38: */ /^(?:\\()/,\r\n        /* 39: */ /^(?:\\))/,\r\n        /* 40: */ /^(?:,)/,\r\n        /* 41: */ /^(?:$)/,\r\n      ],\r\n\r\n      conditions: {\r\n        INITIAL: {\r\n          rules: [\r\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\r\n            19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\r\n            36, 37, 38, 39, 40, 41,\r\n          ],\r\n\r\n          inclusive: true,\r\n        },\r\n      },\r\n    };\r\n\r\n    return lexer;\r\n  })();\r\n  parser.lexer = lexer;\r\n\r\n  function Parser() {\r\n    this.yy = {};\r\n  }\r\n  Parser.prototype = parser;\r\n  parser.Parser = Parser;\r\n\r\n  return new Parser();\r\n})();\r\n\r\nmodule.exports = { parser };\r\n"],"names":["parser","JisonParserError","msg","hash","Object","defineProperty","enumerable","writable","value","stacktrace","exception","Error","ex2","message","stack","hasOwnProperty","captureStackTrace","constructor","setPrototypeOf","prototype","create","name","bp","s","rv","p","pop","r","rule","i","l","length","push","bda","d","idx","g","goto","j","bt","len","y","symbol","t","type","a","state","m","mode","n","q","z","shift","c","u","e","apply","trace","no_op_trace","yy","options","hasPartialLrUpgradeOnConflict","errorRecoveryTokenDiscardCount","symbols_","$accept","$end","ADD","ANGLE","CHS","COMMA","CSS_CPROP","CSS_VAR","DIV","EMS","EOF","EXS","FREQ","LENGTH","LPAREN","MAX","MIN","MUL","NESTED_CALC","NUMBER","PERCENTAGE","PREFIX","REMS","RES","RPAREN","SUB","TIME","VHS","VMAXS","VMINS","VWS","css_value","css_variable","error","expression","math_expression","terminals_","TERROR","originalQuoteName","originalParseError","cleanupAfterParse","constructParseErrorInfo","yyMergeLocationInfo","__reentrant_call_depth","__error_infos","__error_recovery_infos","quoteName","parser_quoteName","id_str","getSymbolName","parser_getSymbolName","key","describeSymbol","parser_describeSymbol","terminal_descriptions_","id","collect_expected_token_set","parser_collect_expected_token_set","do_not_describe","tokenset","check","state_descriptions_","table","productions_","performAction","parser__PerformAction","yystate","yysp","yyvstack","lexer","$","operator","left","right","prefix","parseFloat","fallback","unit","exec","prev","defaultActions","parseError","str","ExceptionClass","recoverable","destroy","parse","input","self","Array","sstack","vstack","sp","NO_ACTION","__lexer__","sharedState_yy","undefined","pre_parse","post_parse","pre_lex","post_lex","assert","ASSERT","yyGetSharedState","shallow_copy_noclobber","dst","src","k","call","parseErrorAlt","quoteNameAlt","parser_cleanupAfterParse","resultValue","invoke_post_methods","do_not_nuke_errorinfos","cleanupAfterLex","el","parser_constructParseErrorInfo","ex","expected","pei","errStr","text","match","yytext","token","token_id","line","yylineno","action","new_state","newState","symbol_stack","state_stack","value_stack","stack_pointer","destructParseErrorInfo","rec","stdLex","lex","fastLex","yyval","_$","yyrulelen","this_production","retval","setInput","canIUse","lexerInfo","errSymbolDescr","showPosition","join","ntsymbol","JisonLexerError","ERROR","__currentRuleSet__","__decompressed","done","_backtrack","_input","_more","_signaled_error_token","conditionStack","matched","matches","offset","yyleng","yylloc","constructLexErrorInfo","lexer_constructLexErrorInfo","show_input_position","indexOf","prettyPrintRange","test","pos_str","loc","destructLexErrorInfo","lexer_parseError","yyerror","yyError","lineno_msg","lexerErrorsAreRecoverable","args","slice","arguments","extra_error_attributes","lexer_cleanupAfterLex","clear","lexer_clear","col","last_column","first_line","first_column","last_line","range","lexer_setInput","rules","rule_re","conditions","spec","rule_ids","rule_regexes","rule_new_ids","__rule_regexes","__rule_count","editRemainingInput","lexer_editRemainingInput","callback","cpsArg","lexer_input","ch","slice_len","lines","ch2","unput","lexer_unput","split","substr","pre","pre_lines","more","lexer_more","reject","lexer_reject","backtrack_lexer","less","lexer_less","pastInput","lexer_pastInput","maxSize","maxLines","past","substring","replace","upcomingInput","lexer_upcomingInput","next","lexer_showPosition","maxPrefix","maxPostfix","deriveLocationInfo","lexer_deriveYYLLOC","actual","preceding","following","current","lexer_prettyPrintRange","context_loc","context_loc2","CONTEXT","CONTEXT_TAIL","MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT","l0","Math","max","l1","lineno_display_width","log10","ws_prefix","nonempty_line_indexes","map","injectLineNumber","index","lno","lno_pfx","errpfx","lead","mark","trim","clip_start","clip_end","intermediate_line","splice","describeYYLLOC","lexer_describe_yylloc","display_range_too","l2","c1","c2","dl","dc","r1","r2","test_match","lexer_test_match","indexed_rule","backup","match_str","match_str_len","lexer_next","tempMatch","_currentRules","trackPosition","topState","regexes","flex","pendingInput","activeCondition","conditionStackDepth","lexer_lex","lexer_fastLex","lexer_canIUse","begin","lexer_begin","condition","pushState","lexer_pushState","popState","lexer_popState","lexer_topState","abs","lexer__currentRules","stateStackSize","lexer_stateStackSize","lexer__performAction","yyrulenumber","YY_START","simpleCaseActionClusters","INITIAL","inclusive","Parser","module"],"mappings":";;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAIA,MAAM,GAAI,YAAY;AACxB;AACA;AACA;AACA;AACA,EAAA,SAASC,gBAAgBA,CAACC,GAAG,EAAEC,IAAI,EAAE;AACnCC,IAAAA,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE;AAClCC,MAAAA,UAAU,EAAE,KAAK;AACjBC,MAAAA,QAAQ,EAAE,KAAK;AACfC,MAAAA,KAAK,EAAE,kBAAA;AACT,KAAC,CAAC,CAAA;AAEF,IAAA,IAAIN,GAAG,IAAI,IAAI,EAAEA,GAAG,GAAG,KAAK,CAAA;AAE5BE,IAAAA,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,SAAS,EAAE;AACrCC,MAAAA,UAAU,EAAE,KAAK;AACjBC,MAAAA,QAAQ,EAAE,IAAI;AACdC,MAAAA,KAAK,EAAEN,GAAAA;AACT,KAAC,CAAC,CAAA;IAEF,IAAI,CAACC,IAAI,GAAGA,IAAI,CAAA;AAEhB,IAAA,I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AA;AACV,SAAA;AAEA7J,QAAAA,CAAC,GAAG,IAAI,CAACgF,uBAAuB,CAC9B,mCAAmC,EACnC6E,EAAE,EACF,IAAI,EACJ,KACF,CAAC,CAAA;AACD2B,QAAAA,MAAM,GAAG,KAAK,CAAA;AACdtL,QAAAA,CAAC,GAAG,IAAI,CAACsH,UAAU,CAACxH,CAAC,CAACgK,MAAM,EAAEhK,CAAC,EAAE,IAAI,CAACxB,gBAAgB,CAAC,CAAA;AACvD,QAAA,IAAI,OAAO0B,CAAC,KAAK,WAAW,EAAE;AAC5BsL,UAAAA,MAAM,GAAGtL,CAAC,CAAA;AACZ,SAAA;AACF,OAAC,SAAS;QACRsL,MAAM,GAAG,IAAI,CAACzG,iBAAiB,CAACyG,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAAA;QACnD,IAAI,CAACtG,sBAAsB,EAAE,CAAA;AAC/B,OAAC;;AAED,MAAA,OAAOsG,MAAM,CAAA;AACf,KAAA;GACD,CAAA;AACDjN,EAAAA,MAAM,CAACuG,kBAAkB,GAAGvG,MAAM,CAACiJ,UAAU,CAAA;AAC7CjJ,EAAAA,MAAM,CAACsG,iBAAiB,GAAGtG,MAAM,CAAC8G,SAAS,CAAA;AAC3C;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,IAAIuB,KAAK,GAAI,YAAY;AACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,IAAA,SAASoF,eAAeA,CAACvN,GAAG,EAAEC,IAAI,EAAE;AAClCC,MAAAA,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE;AAClCC,QAAAA,UAAU,EAAE,KAAK;AACjBC,QAAAA,QAAQ,EAAE,KAAK;AACfC,QAAAA,KAAK,EAAE,iBAAA;AACT,OAAC,CAAC,CAAA;AAEF,MAAA,IAAIN,GAAG,IAAI,IAAI,EAAEA,GAAG,GAAG,KAAK,CAAA;AAE5BE,MAAAA,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,SAAS,EAAE;AACrCC,QAAAA,UAAU,EAAE,KAAK;AACjBC,QAAAA,QAAQ,EAAE,IAAI;AACdC,QAAAA,KAAK,EAAEN,GAAAA;AACT,OAAC,CAAC,CAAA;MAEF,IAAI,CAACC,IAAI,GAAGA,IAAI,CAAA;AAChB,MAAA,IAAIM,UAAU,CAAA;AAEd,MAAA,IAAIN,IAAI,IAAIA,IAAI,CAACO,SAAS,YAAYC,KAAK,EAAE;AAC3C,QAAA,IAAIC,GAAG,GAAGT,IAAI,CAACO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CA,QAAA,CAAC,EAAE,CAAC;AAEJ;AACA;AACA,QAAA,CAAC,EAAE,CAAC;AAEJ;AACA;AACA,QAAA,CAAC,EAAE,CAAC;AAEJ;AACA;AACA,QAAA,CAAC,EAAE,EAAE;AAEL;AACA;AACA,QAAA,CAAC,EAAE,EAAE;AAEL;AACA;AACA,QAAA,CAAC,EAAE,EAAE;AAEL;AACA;AACA,QAAA,CAAC,EAAE,EAAE;AAEL;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,CAAC;AAEL;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,CAAC;AAEL;AACA;AACA,QAAA,EAAE,EAAE,CAAC;AAEL;AACA;AACA,QAAA,EAAE,EAAE,EAAE;AAEN;AACA;AACA,QAAA,EAAE,EAAE,CAAA;OACL;AAEDzH,MAAAA,KAAK,EAAE,UACK,wBAAwB,WACxB,UAAU,WACV,SAAS,WACT,SAAS,WACT,SAAS,WACT,QAAQ,WACR,8BAA8B,WAC9B,8BAA8B,WAC9B,8BAA8B,WAC9B,8BAA8B,WAC9B,8BAA8B,WAC9B,8BAA8B,WAC9B,+BAA+B,WAC/B,gCAAgC,WAChC,+BAA+B,WAC/B,gCAAgC,WAChC,6BAA6B,WAC7B,8BAA8B,WAC9B,8BAA8B,WAC9B,+BAA+B,WAC/B,+BAA+B,WAC/B,gCAAgC,WAChC,gCAAgC,WAChC,8BAA8B,WAC9B,8BAA8B,WAC9B,8BAA8B,WAC9B,+BAA+B,WAC/B,8BAA8B,WAC9B,8BAA8B,WAC9B,gCAAgC,WAChC,gCAAgC,WAChC,2BAA2B,WAC3B,4BAA4B,WAC5B,aAAa,WACb,YAAY,WACZ,YAAY,WACZ,YAAY,WACZ,eAAe,WACf,SAAS,WACT,SAAS,WACT,QAAQ,WACR,QAAQ,CACnB;AAEDE,MAAAA,UAAU,EAAE;AACVwH,QAAAA,OAAO,EAAE;AACP1H,UAAAA,KAAK,EAAE,CACL,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAChE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAClE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CACvB;AAED2H,UAAAA,SAAS,EAAE,IAAA;AACb,SAAA;AACF,OAAA;KACD,CAAA;AAED,IAAA,OAAO1P,KAAK,CAAA;AACd,GAAC,EAAG,CAAA;EACJrI,MAAM,CAACqI,KAAK,GAAGA,KAAK,CAAA;EAEpB,SAAS2P,MAAMA,GAAG;AAChB,IAAA,IAAI,CAACrU,EAAE,GAAG,EAAE,CAAA;AACd,GAAA;EACAqU,MAAM,CAAC7W,SAAS,GAAGnB,MAAM,CAAA;EACzBA,MAAM,CAACgY,MAAM,GAAGA,MAAM,CAAA;EAEtB,OAAO,IAAIA,MAAM,EAAE,CAAA;AACrB,CAAC,EAAG,CAAA;AAEJC,IAAAA,QAAc,GAAG;AAAEjY,EAAAA,MAAAA;AAAO;;;;"}