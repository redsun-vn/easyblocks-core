{"version":3,"file":"richTextEditorActions.cjs","sources":["../../../../../src/compiler/builtins/$richText/richTextEditorActions.ts"],"sourcesContent":["import { nonNullable } from \"@/utils\";\nimport { BaseRange, Editor, Node, Range, Text, Transforms } from \"slate\";\nimport { SetNonNullable } from \"type-fest\";\nimport { RichTextComponentConfig } from \"./$richText\";\nimport { BlockElement } from \"./$richText.types\";\nimport { RichTextPartComponentConfig } from \"./$richTextPart/$richTextPart\";\nimport { convertEditorValueToRichTextElements } from \"./utils/convertEditorValueToRichTextElements\";\nimport { getFocusedRichTextPartsConfigPaths } from \"./utils/getFocusedRichTextPartsConfigPaths\";\n\ntype SelectedEditor = SetNonNullable<Editor, \"selection\">;\n\nfunction isEditorSelection(editor: Editor): editor is SelectedEditor {\n  return editor.selection !== null;\n}\n\nfunction updateSelection<\n  T extends keyof Omit<\n    RichTextPartComponentConfig,\n    \"_id\" | \"_component\" | \"value\"\n  >\n>(\n  editor: Editor,\n  key: T,\n  ...values: Array<RichTextPartComponentConfig[T]>\n):\n  | {\n    elements: RichTextComponentConfig[\"elements\"][string];\n    focusedRichTextParts: Array<string>;\n  }\n  | undefined {\n  if (!isEditorSelection(editor)) {\n    return;\n  }\n\n  const isSelectionCollapsed = Range.isCollapsed(editor.selection);\n\n  if (values.length === 1) {\n    if (key === \"TextWrapper\" && isSelectionCollapsed) {\n      expandCurrentSelectionToWholeTextPart(editor);\n    }\n\n    // If `values` contains one element, we want to apply this value to all text nodes.\n    Editor.addMark(editor, key, values[0]);\n\n    if (key === \"TextWrapper\") {\n      if (values[0].length > 0) {\n        const firstSelectedNodeEntry = Node.first(\n          editor,\n          editor.selection.anchor.path\n        );\n\n        const lastSelectedNodeEntry = Node.last(\n          editor,\n          editor.selection.focus.path\n        );\n\n        if (Text.isText(firstSelectedNodeEntry[0])) {\n          const firstSelectedNode = firstSelectedNodeEntry[0];\n          const lastSelectedNode = lastSelectedNodeEntry[0];\n\n          if (firstSelectedNode !== lastSelectedNode) {\n            Transforms.setNodes(\n              editor,\n              {\n                color: firstSelectedNode.color,\n                font: firstSelectedNode.font,\n              },\n              {\n                match: Text.isText,\n              }\n            );\n          }\n        }\n      }\n    }\n  } else {\n    // If `values` contains multiple values, we want to update each selected text node separately with its\n    // corresponding value. To do that, we need to obtain selection range for each selected text node\n    // and apply correct value.\n    const selectedTextNodeEntries = Array.from(\n      Editor.nodes<Text>(editor, {\n        match: Text.isText,\n      })\n    );\n\n    const selectedTextNodesRanges = selectedTextNodeEntries\n      .map(([, textNodePath]) => {\n        return Range.intersection(\n          editor.selection,\n          Editor.range(editor, textNodePath)\n        );\n      })\n      .filter<BaseRange>(nonNullable());\n\n    Editor.withoutNormalizing(editor, () => {\n      selectedTextNodesRanges.reverse().forEach((range, index) => {\n        Transforms.setNodes(\n          editor,\n          {\n            [key]: values[index],\n          },\n          {\n            at: range,\n            match: Text.isText,\n            split: true,\n          }\n        );\n      });\n    });\n  }\n\n  const richTextElements = convertEditorValueToRichTextElements(\n    editor.children as Array<BlockElement>\n  );\n\n  const newFocusedRichTextParts = getFocusedRichTextPartsConfigPaths(editor);\n\n  return {\n    elements: richTextElements,\n    focusedRichTextParts: newFocusedRichTextParts,\n  };\n}\n\nexport { updateSelection };\n\nfunction expandCurrentSelectionToWholeTextPart(editor: Editor) {\n  const textPartPath = Editor.path(editor, editor.selection!.anchor.path);\n\n  Transforms.setSelection(editor, {\n    anchor: Editor.start(editor, textPartPath),\n    focus: Editor.end(editor, textPartPath),\n  });\n}\n"],"names":["isEditorSelection","editor","selection","updateSelection","key","_len","arguments","length","values","Array","_key","isSelectionCollapsed","Range","isCollapsed","expandCurrentSelectionToWholeTextPart","Editor","addMark","firstSelectedNodeEntry","Node","first","anchor","path","lastSelectedNodeEntry","last","focus","Text","isText","firstSelectedNode","lastSelectedNode","Transforms","setNodes","color","font","match","selectedTextNodeEntries","from","nodes","selectedTextNodesRanges","map","_ref","textNodePath","intersection","range","filter","nonNullable","withoutNormalizing","reverse","forEach","index","at","split","richTextElements","convertEditorValueToRichTextElements","children","newFocusedRichTextParts","getFocusedRichTextPartsConfigPaths","elements","focusedRichTextParts","textPartPath","setSelection","start","end"],"mappings":"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"}