{"version":3,"file":"withEasyblocks.cjs","sources":["../../../../../src/compiler/builtins/$richText/withEasyblocks.ts"],"sourcesContent":["import { deepCompare, keys, uniqueId } from \"@/utils\";\nimport {\n  Editor,\n  NodeEntry,\n  Element as SlateElement,\n  Node as SlateNode,\n  Text,\n  Transforms,\n} from \"slate\";\nimport { RichTextBlockElementType } from \"./$richTextBlockElement/$richTextBlockElement\";\n\ntype ComparableText = Pick<Text, \"color\" | \"font\">;\n\n/**\n * Tracks which ids were used during current normalization run\n */\nconst USED_IDS = new Set<string>();\n\n/**\n * Keeps track what was the previous id before generating the unique id. This is needed because Slate rerenders before\n * our config updates and it wouldn't know which compiled component to render.\n */\nexport const NORMALIZED_IDS_TO_IDS = new Map<string, string>();\n\nfunction withEasyblocks(editor: Editor): Editor {\n  const { /*insertText,*/ normalizeNode } = editor;\n\n  // editor.insertText = (text) => {\n  //   // Verify if the current selection is placed at the end of an inline element. If yes, set the selection to start of\n  //   // the next element before adding new text. This allows to break out from the inline element if it's placed at the end of line.\n  //   if (editor.selection && Range.isCollapsed(editor.selection)) {\n  //     const selectedNodeParent = Editor.parent(\n  //       editor,\n  //       editor.selection.focus.path\n  //     );\n\n  //     if (selectedNodeParent) {\n  //       const [parentNode, parentNodePath] = selectedNodeParent;\n\n  //       if (SlateElement.isElement(parentNode) && editor.isInline(parentNode)) {\n  //         const isCursorSetAtTheEnd = Editor.isEnd(\n  //           editor,\n  //           editor.selection.focus,\n  //           parentNodePath\n  //         );\n\n  //         const nodePointAfterInlineElement = Editor.after(\n  //           editor,\n  //           parentNodePath\n  //         );\n\n  //         if (isCursorSetAtTheEnd && nodePointAfterInlineElement) {\n  //           Transforms.setSelection(editor, {\n  //             anchor: nodePointAfterInlineElement,\n  //             focus: nodePointAfterInlineElement,\n  //           });\n  //         }\n  //       }\n  //     }\n  //   }\n\n  //   insertText(text);\n  // };\n\n  editor.normalizeNode = (entry) => {\n    // When copying text content from content editable element, Slate wraps pasted content into top most element.\n    // We need to unwrap each block element that is nested within another block element.\n    if (unwrapBlockElementsNestedWithinBlockElement(editor, entry)) {\n      return;\n    }\n\n    // Slate by default compares text elements and merges them, but to compare them it uses strict equality comparison algorithm.\n    // We need to compare them using our own algorithm.\n    if (mergeVisuallyTheSameOrEmptyTextNodes(editor, entry)) {\n      return;\n    }\n\n    // if (normalizeEmptyTextNodesAfterInlineElements(editor, entry)) {\n    //   return;\n    // }\n\n    // Rich text and its elements contains collections. Each item of collection should have unique id.\n    if (updateNonUniqueIds(editor, entry)) {\n      return;\n    }\n\n    // Slate normalizes fields from deepest to lowest. The lowest element is editor element which has empty path.\n    if (entry[1].length === 0) {\n      USED_IDS.clear();\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n}\n\nexport { withEasyblocks };\n\nfunction unwrapBlockElementsNestedWithinBlockElement(\n  editor: Editor,\n  entry: NodeEntry<SlateNode>\n): boolean {\n  const [node, path] = entry;\n\n  if (\n    SlateElement.isElement(node) &&\n    // This cast is fine since `RichTextBlockElementType` overlaps with type of `node.type`.\n    [\"bulleted-list\", \"numbered-list\", \"paragraph\"].includes(\n      node.type as RichTextBlockElementType\n    )\n  ) {\n    const nodeParent = SlateNode.parent(editor, path);\n\n    if (SlateElement.isElement(nodeParent)) {\n      if (nodeParent.type === node.type) {\n        Transforms.unwrapNodes(editor, { at: path });\n        return true;\n      }\n\n      // For now there is only one case where block element can be nested within block element of different type,\n      // it can happen while pasting content from one $richText to another. We want to keep the type of pasted content\n      // so instead of unwrapping nodes, we lift them one level up.\n      if (\n        nodeParent.type !== node.type &&\n        [\"bulleted-list\", \"numbered-list\", \"paragraph\"].includes(\n          nodeParent.type as RichTextBlockElementType\n        )\n      ) {\n        Transforms.liftNodes(editor, { at: path });\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction updateNonUniqueIds(\n  editor: Editor,\n  entry: NodeEntry<SlateNode>\n): boolean {\n  const [node, path] = entry;\n\n  if (Text.isText(node) || SlateElement.isElement(node)) {\n    if (USED_IDS.has(node.id)) {\n      const newId = uniqueId();\n      NORMALIZED_IDS_TO_IDS.set(newId, node.id);\n      Transforms.setNodes(\n        editor,\n        {\n          id: newId,\n        },\n        {\n          at: path,\n          match: (n) =>\n            (Text.isText(n) || SlateElement.isElement(n)) && n.id === node.id,\n        }\n      );\n      return true;\n    } else {\n      USED_IDS.add(node.id);\n    }\n  }\n\n  return false;\n}\n\nfunction mergeVisuallyTheSameOrEmptyTextNodes(\n  editor: Editor,\n  entry: NodeEntry<SlateNode>\n): boolean {\n  const [node, path] = entry;\n\n  if (\n    SlateElement.isElement(node) &&\n    (node.type === \"text-line\" || node.type === \"list-item\")\n  ) {\n    const textLineChildren = Array.from(SlateNode.children(editor, path));\n\n    if (textLineChildren.length > 1) {\n      for (\n        let childIndex = 0;\n        childIndex < textLineChildren.length - 1;\n        childIndex++\n      ) {\n        const [currentChildNode, currentChildPath] =\n          textLineChildren[childIndex];\n        const [nextChildNode, nextChildPath] = textLineChildren[childIndex + 1];\n\n        if (Text.isText(currentChildNode) && Text.isText(nextChildNode)) {\n          if (compareText(currentChildNode, nextChildNode)) {\n            Transforms.mergeNodes(editor, {\n              at: nextChildPath,\n              match: (node) => Text.isText(node),\n            });\n\n            return true;\n          }\n\n          if (\n            nextChildNode.text.trim() === \"\" &&\n            childIndex + 1 < textLineChildren.length - 1 &&\n            currentChildNode.TextWrapper.length === 0\n          ) {\n            Transforms.mergeNodes(editor, {\n              at: nextChildPath,\n              match: (node) => Text.isText(node),\n            });\n\n            return true;\n          }\n\n          // `Transforms.mergeNodes` always merges node/nodes at given position into PREVIOUS node.\n          // In this case, we want to merge node at current position into next one.\n          if (\n            currentChildNode.text.trim() === \"\" &&\n            nextChildNode !== undefined\n          ) {\n            Transforms.setNodes(\n              editor,\n              {\n                color: nextChildNode.color,\n                font: nextChildNode.font,\n              },\n              {\n                at: currentChildPath,\n                match: (node) => Text.isText(node),\n              }\n            );\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n// This function might be useful in the future, but right now it's not needed.\n\n// Slate normalization rules states that an inline element cannot be first or last child of block element.\n// Slate during its own normalization will add empty Text nodes before or/and after inline element.\n// Those Text nodes will be missing properties we add during constructing Slate value based on Shopstory config\n// thus it will make compilation error because of missing schema prop values.\n// function normalizeEmptyTextNodesAfterInlineElements(\n//   editor: Editor,\n//   entry: NodeEntry<SlateNode>\n// ): boolean {\n//   const [node, path] = entry;\n\n//   if (\n//     SlateElement.isElement(node) &&\n//     (node.type === \"text-line\" || node.type === \"list-item\")\n//   ) {\n//     for (let index = 0; index < node.children.length; index++) {\n//       const childNode = node.children[index];\n//       const previousNode = node.children[index - 1];\n//       const nextNode = node.children[index + 1];\n\n//       if (\n//         previousNode &&\n//         nextNode &&\n//         isElementInlineWrapperElement(previousNode) &&\n//         isElementInlineWrapperElement(nextNode)\n//       ) {\n//         if (Text.isText(childNode) && childNode.text === \"\") {\n//           Transforms.removeNodes(editor, {\n//             at: [...path, index],\n//           });\n//           return true;\n//         }\n//       }\n\n//       if (\n//         childNode &&\n//         nextNode &&\n//         isElementInlineWrapperElement(childNode) &&\n//         isElementInlineWrapperElement(nextNode)\n//       ) {\n//         const nextNodePath = [...path, index + 1];\n\n//         Transforms.mergeNodes(editor, {\n//           at: nextNodePath,\n//         });\n\n//         return true;\n//       }\n//     }\n//   }\n\n//   return false;\n// }\n\nfunction filterNonComparableProperties(obj: Text): ComparableText {\n  return keys(obj)\n    .filter<keyof ComparableText>((key): key is keyof ComparableText =>\n      [\"color\", \"font\", \"TextWrapper\"].includes(key)\n    )\n    .reduce((filteredObject, currentKey) => {\n      filteredObject[currentKey] = obj[currentKey];\n      return filteredObject;\n    }, {} as ComparableText);\n}\n\nfunction compareText(text1: Text, text2: Text): boolean {\n  let areEqual = true;\n\n  const part1Keys = keys(filterNonComparableProperties(text1));\n  const part2Keys = keys(filterNonComparableProperties(text2));\n\n  if (part1Keys.length !== part2Keys.length) {\n    return false;\n  }\n\n  for (let index = 0; index < part1Keys.length; index++) {\n    const key = part1Keys[index];\n    const part1Value = text1[key];\n    const part2Value = text2[key];\n    const areValuesEqual = deepCompare(part1Value, part2Value);\n\n    if (!areValuesEqual) {\n      areEqual = false;\n      break;\n    }\n  }\n\n  return areEqual;\n}\n"],"names":["USED_IDS","Set","NORMALIZED_IDS_TO_IDS","Map","withEasyblocks","editor","normalizeNode","entry","unwrapBlockElementsNestedWithinBlockElement","mergeVisuallyTheSameOrEmptyTextNodes","updateNonUniqueIds","length","clear","node","path","SlateElement","isElement","includes","type","nodeParent","SlateNode","parent","Transforms","unwrapNodes","at","liftNodes","Text","isText","has","id","newId","uniqueId","set","setNodes","match","n","add","textLineChildren","Array","from","children","childIndex","currentChildNode","currentChildPath","nextChildNode","nextChildPath","compareText","mergeNodes","text","trim","TextWrapper","undefined","color","font","filterNonComparableProperties","obj","keys","filter","key","reduce","filteredObject","currentKey","text1","text2","areEqual","part1Keys","part2Keys","index","part1Value","part2Value","areValuesEqual","deepCompare"],"mappings":"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"}