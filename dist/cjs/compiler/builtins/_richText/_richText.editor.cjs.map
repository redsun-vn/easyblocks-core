{"version":3,"file":"_richText.editor.cjs","sources":["../../../../../src/compiler/builtins/$richText/$richText.editor.tsx"],"sourcesContent":["\"use client\";\nimport { deepClone, deepCompare, dotNotationGet } from \"@/utils\";\nimport throttle from \"lodash/throttle\";\nimport React, {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { flushSync } from \"react-dom\";\nimport {\n  BaseRange,\n  Descendant,\n  Editor,\n  NodeEntry,\n  Range,\n  Text,\n  Transforms,\n  createEditor,\n} from \"slate\";\nimport type {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderPlaceholderProps,\n} from \"slate-react\";\nimport { Editable, ReactEditor, Slate, withReact } from \"slate-react\";\nimport { Box } from \"../../../components/Box/Box\";\nimport {\n  ComponentBuilder,\n  InternalNoCodeComponentProps,\n} from \"../../../components/ComponentBuilder/ComponentBuilder\";\nimport { RichTextChangedEvent } from \"../../../events\";\nimport { getFallbackForLocale } from \"../../../locales\";\nimport { responsiveValueFill } from \"../../../responsiveness\";\nimport { Devices, ResponsiveValue } from \"../../../types\";\nimport { compileBox, getBoxStyles } from \"../../box\";\nimport { getDevicesWidths } from \"../../devices\";\nimport { duplicateConfig } from \"../../duplicateConfig\";\nimport type { RichTextComponentConfig } from \"./$richText\";\nimport {\n  RICH_TEXT_CONFIG_SYNC_THROTTLE_TIMEOUT,\n  RICH_TEXT_FOCUSED_FIELDS_SYNC_THROTTLE_TIMEOUT,\n} from \"./$richText.constants\";\nimport { Alignment, BlockElement } from \"./$richText.types\";\nimport { RichTextBlockElementCompiledComponentConfig } from \"./$richTextBlockElement/$richTextBlockElement\";\nimport { RichTextPartComponentConfig } from \"./$richTextPart/$richTextPart\";\nimport { RichTextPartClient } from \"./$richTextPart/$richTextPart.client\";\nimport { getAbsoluteRichTextPartPath } from \"./getAbsoluteRichTextPartPath\";\nimport { updateSelection } from \"./richTextEditorActions\";\nimport { convertEditorValueToRichTextElements } from \"./utils/convertEditorValueToRichTextElements\";\nimport { convertRichTextElementsToEditorValue } from \"./utils/convertRichTextElementsToEditorValue\";\nimport { createTemporaryEditor } from \"./utils/createTemporaryEditor\";\nimport { extractElementsFromCompiledComponents } from \"./utils/extractElementsFromCompiledComponents\";\nimport { extractTextPartsFromCompiledComponents } from \"./utils/extractTextPartsFromCompiledComponents\";\nimport { getEditorSelectionFromFocusedFields } from \"./utils/getEditorSelectionFromFocusedFields\";\nimport { getFocusedFieldsFromSlateSelection } from \"./utils/getFocusedFieldsFromSlateSelection\";\nimport { getFocusedRichTextPartsConfigPaths } from \"./utils/getFocusedRichTextPartsConfigPaths\";\nimport { getRichTextComponentConfigFragment } from \"./utils/getRichTextComponentConfigFragment\";\nimport { NORMALIZED_IDS_TO_IDS, withEasyblocks } from \"./withEasyblocks\";\n\ninterface RichTextProps extends InternalNoCodeComponentProps {\n  elements: Array<\n    React.ReactElement<{\n      compiled: RichTextBlockElementCompiledComponentConfig;\n    }>\n  >;\n  align: ResponsiveValue<Alignment>;\n}\n\nfunction RichTextEditor(props: RichTextProps) {\n  const { editorContext } = (window.parent as any).editorWindowAPI;\n\n  const {\n    actions,\n    contextParams,\n    form,\n    focussedField,\n    locales,\n    setFocussedField,\n  } = editorContext;\n\n  const {\n    __easyblocks: {\n      path,\n      runtime: { resop, stitches, devices },\n    },\n    align,\n  } = props;\n\n  let richTextConfig: RichTextComponentConfig = dotNotationGet(\n    form.values,\n    path\n  );\n\n  const [editor] = useState(() => withEasyblocks(withReact(createEditor())));\n\n  const localizedRichTextElements =\n    richTextConfig.elements[contextParams.locale];\n\n  const fallbackRichTextElements = getFallbackForLocale(\n    richTextConfig.elements,\n    contextParams.locale,\n    locales\n  );\n\n  const richTextElements =\n    localizedRichTextElements ?? fallbackRichTextElements;\n\n  const richTextElementsConfigPath = `${path}.elements.${contextParams.locale}`;\n\n  const [editorValue, setEditorValue] = useState(() =>\n    convertRichTextElementsToEditorValue(richTextElements)\n  );\n\n  // If rich text has no value, we initialize it with default config by updating it during first render\n  // This is only possible when we open entry for non main locale without fallback, this is total edge case\n  if (richTextElements.length === 0 && !fallbackRichTextElements) {\n    // We only want to show rich text for default config within this component, we don't want to update raw content\n    // To prevent implicit update of raw content we make a deep copy.\n    richTextConfig = deepClone(richTextConfig);\n    richTextConfig.elements[contextParams.locale] =\n      convertEditorValueToRichTextElements(editorValue);\n  }\n\n  /**\n   * Controls the visibility of decoration imitating browser selection of\n   * the selected text after the user has blurred the content editable element.\n   */\n  const [isDecorationActive, setIsDecorationActive] = useState(false);\n\n  /**\n   * Keeps track what caused last change to editor value.\n   * This is used in two cases:\n   * - text-only changes of editable content shouldn't trigger update of `editor.children` (\"text-input\")\n   * - changes from outside of editable content shouldn't trigger writing to editor's history within change callback (\"external\")\n   */\n  const lastChangeReason = useRef<\"external\" | \"text-input\" | \"paste\">(\n    \"text-input\"\n  );\n\n  /**\n   * Whether the content editable is enabled or not. We enable it through double click.\n   */\n  const [isEnabled, setIsEnabled] = useState(false);\n  const previousRichTextComponentConfig = useRef<RichTextComponentConfig>();\n  const currentSelectionRef = useRef<BaseRange | null>(null);\n\n  const isConfigChanged = !isConfigEqual(\n    previousRichTextComponentConfig.current,\n    richTextConfig\n  );\n\n  if (previousRichTextComponentConfig.current && isConfigChanged) {\n    if (lastChangeReason.current !== \"paste\") {\n      lastChangeReason.current = \"external\";\n    }\n\n    previousRichTextComponentConfig.current = richTextConfig;\n    const nextEditorValue =\n      convertRichTextElementsToEditorValue(richTextElements);\n    // React bails out the render if state setter function is invoked during the render phase.\n    // Doing it makes Slate always up-to date with the latest config if it's changed from outside.\n    // https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops\n    setEditorValue(nextEditorValue);\n    editor.children = nextEditorValue;\n\n    if (isEnabled) {\n      const newEditorSelection = getEditorSelectionFromFocusedFields(\n        focussedField,\n        form\n      );\n\n      if (isDecorationActive) {\n        currentSelectionRef.current = newEditorSelection;\n      } else {\n        // Slate gives us two methods to update its selection:\n        // - `setSelection` updates current selection, so `editor.selection` must be not null\n        // - `select` sets the selection, so `editor.selection` must be null\n        if (newEditorSelection !== null && editor.selection !== null) {\n          Transforms.setSelection(editor, newEditorSelection);\n        } else if (newEditorSelection !== null && editor.selection === null) {\n          Transforms.select(editor, newEditorSelection);\n        } else {\n          Transforms.deselect(editor);\n        }\n      }\n    }\n  }\n\n  useLayoutEffect(() => {\n    if (\n      isDecorationActive &&\n      currentSelectionRef.current !== null &&\n      !Range.isCollapsed(currentSelectionRef.current)\n    ) {\n      splitStringNodes(editor, currentSelectionRef.current);\n\n      return () => {\n        unwrapStringNodesContent(editor);\n      };\n    }\n  }, [editor, isDecorationActive, richTextConfig]);\n\n  const isRichTextActive = focussedField.some((focusedField: any) =>\n    focusedField.startsWith(path)\n  );\n\n  useLayoutEffect(() => {\n    // When rich text becomes inactive we want to restore all original [data-slate-string] nodes\n    // by removing all span wrappers that we added to show the mocked browser selection.\n    if (!isRichTextActive) {\n      unwrapStringNodesContent(editor);\n    }\n  }, [editor, isRichTextActive]);\n\n  useEffect(() => {\n    // We set previous value of rich text only once, then we manually assign it when needed.\n    previousRichTextComponentConfig.current = richTextConfig;\n  }, []);\n\n  useEffect(\n    // Component is blurred when the user selects other component in editor. This is different from blurring content editable.\n    // Content editable can be blurred, but the component can remain active ex. when we select some text within content editable\n    // and want to update its color from the sidebar.\n    function handleRichTextBlur() {\n      if (!isRichTextActive && isEnabled) {\n        // editor.children = deepClone(editorValue);\n        setIsEnabled(false);\n        currentSelectionRef.current = null;\n      }\n\n      if (!editor.selection) {\n        return;\n      }\n\n      if (!isRichTextActive) {\n        Transforms.deselect(editor);\n\n        const isSlateValueEmpty = isEditorValueEmpty(\n          editor.children as Array<BlockElement>\n        );\n\n        // When value for current locale is empty we want to show value from fallback value instead of placeholder\n        // if the fallback value is present.\n        if (isSlateValueEmpty && fallbackRichTextElements !== undefined) {\n          const nextRichTextElement = deepClone(richTextConfig);\n          delete nextRichTextElement.elements[contextParams.locale];\n          editor.children = convertRichTextElementsToEditorValue(\n            fallbackRichTextElements\n          );\n          form.change(path, nextRichTextElement);\n        }\n      }\n    },\n    [focussedField, isEnabled, isRichTextActive]\n  );\n\n  useEffect(() => {\n    // If editor has been refocused and it was blurred earlier we have to disable the decoration to show only browser selection\n    if (ReactEditor.isFocused(editor) && isDecorationActive) {\n      setIsDecorationActive(false);\n    }\n  });\n\n  useEffect(() => {\n    function handleRichTextChanged(event: RichTextChangedEvent) {\n      if (!editor.selection) {\n        return;\n      }\n\n      if (event.data.type === \"@easyblocks-editor/rich-text-changed\") {\n        const { payload } = event.data;\n        const { editorContext } = (window.parent as any).editorWindowAPI;\n\n        // Slate is an uncontrolled component and we don't have an easy access to control it.\n        // It keeps its state internally and on each change we convert this state to our format.\n        // This works great because changing content of editable element is easy, we append or remove things.\n        // When we change the color/font of selected text there are many questions:\n        // - is the current selection partial or does it span everything?\n        // - how to split text chunks when selection is partial?\n        // - how to update selection?\n        //\n        // `Editor.addMark` method automatically will split (or not) text chunks, update selection etc.\n        // It will just do all the painful things. After the Slate do its job, we take its current state after the update\n        // and convert it to entry and correct focused fields.\n        const temporaryEditor = createTemporaryEditor(editor);\n\n        const updateSelectionResult = updateSelection(\n          temporaryEditor,\n          payload.prop,\n          ...payload.values\n        );\n\n        if (!updateSelectionResult) {\n          return;\n        }\n\n        currentSelectionRef.current = temporaryEditor.selection;\n\n        actions.runChange(() => {\n          const newRichTextElement: RichTextComponentConfig = {\n            ...richTextConfig,\n            elements: {\n              ...richTextConfig.elements,\n              [editorContext.contextParams.locale]:\n                updateSelectionResult.elements,\n            },\n          };\n\n          form.change(path, newRichTextElement);\n\n          const newFocusedFields =\n            updateSelectionResult.focusedRichTextParts.map(\n              (focusedRichTextPart) =>\n                getAbsoluteRichTextPartPath(\n                  focusedRichTextPart,\n                  path,\n                  editorContext.contextParams.locale\n                )\n            );\n\n          return newFocusedFields;\n        });\n      }\n    }\n\n    window.addEventListener(\"message\", handleRichTextChanged);\n\n    return () => {\n      window.removeEventListener(\"message\", handleRichTextChanged);\n    };\n  }, [richTextConfig, path]);\n\n  const decorate = createTextSelectionDecorator(editor);\n  const Elements = extractElementsFromCompiledComponents(props);\n\n  function renderElement({\n    attributes,\n    children,\n    element,\n  }: RenderElementProps) {\n    const Element = Elements.find(\n      (Element) =>\n        Element._id === element.id ||\n        NORMALIZED_IDS_TO_IDS.get(element.id) === Element._id\n    );\n\n    if (!Element) {\n      // This can only happen if the current locale has no value and has no fallback\n      if (Elements.length === 0) {\n        if (element.type === \"list-item\") {\n          return (\n            <div {...attributes}>\n              <div>{children}</div>\n            </div>\n          );\n        }\n\n        return <div {...attributes}>{children}</div>;\n      }\n\n      throw new Error(\"Missing element\");\n    }\n\n    const compiledStyles = (() => {\n      if (Element._component === \"@easyblocks/rich-text-block-element\") {\n        if (Element.props.type === \"bulleted-list\") {\n          return Element.styled.BulletedList;\n        } else if (Element.props.type === \"numbered-list\") {\n          return Element.styled.NumberedList;\n        } else if (Element.props.type === \"paragraph\") {\n          return Element.styled.Paragraph;\n        }\n      } else if (Element._component === \"@easyblocks/rich-text-line-element\") {\n        if (element.type === \"text-line\") {\n          return Element.styled.TextLine;\n        } else if (element.type === \"list-item\") {\n          return Element.styled.ListItem;\n        }\n      }\n    })();\n\n    if (compiledStyles === undefined) {\n      throw new Error(\"Unknown element type\");\n    }\n\n    return (\n      <Box\n        __compiled={compiledStyles}\n        devices={devices}\n        stitches={stitches}\n        {...attributes}\n        // Element annotation for easier debugging\n        {...(process.env.NODE_ENV === \"development\" && {\n          \"data-shopstory-element-type\": element.type,\n          \"data-shopstory-id\": element.id,\n        })}\n      >\n        {element.type === \"list-item\" ? <div>{children}</div> : children}\n      </Box>\n    );\n  }\n\n  const TextParts = extractTextPartsFromCompiledComponents(props);\n\n  function renderLeaf({ attributes, children, leaf }: RenderLeafProps) {\n    let TextPart = TextParts.find((TextPart) => {\n      return TextPart._id === leaf.id;\n    });\n\n    if (!TextPart) {\n      TextPart = TextParts.find((TextPart) => {\n        return NORMALIZED_IDS_TO_IDS.get(leaf.id) === TextPart._id;\n      });\n    }\n\n    if (!TextPart) {\n      // This can only happen if the current locale has no value and has no fallback\n      if (TextParts.length === 0) {\n        return <span {...attributes}>{children}</span>;\n      }\n\n      throw new Error(\"Missing part\");\n    }\n\n    const TextPartComponent = (\n      <RichTextPartClient\n        value={children}\n        Text={\n          <Box\n            __compiled={TextPart.styled.Text}\n            devices={devices}\n            stitches={stitches}\n            {...attributes}\n          />\n        }\n        TextWrapper={\n          TextPart.components.TextWrapper[0] ? (\n            <ComponentBuilder\n              compiled={TextPart.components.TextWrapper[0]}\n              path={path}\n              components={editorContext.components}\n              passedProps={{\n                __isSelected:\n                  leaf.isHighlighted && leaf.highlightType === \"textWrapper\",\n              }}\n            />\n          ) : undefined\n        }\n      />\n    );\n\n    return TextPartComponent;\n  }\n\n  // Setting `display: flex` for element's aligning on `Editable` component makes default styles\n  // of placeholder insufficient thus they require to explicitly set `top` and `left`.\n  function renderPlaceholder({ attributes, children }: RenderPlaceholderProps) {\n    return (\n      <span\n        {...attributes}\n        style={{\n          ...attributes.style,\n          top: 0,\n          left: 0,\n        }}\n      >\n        {children}\n      </span>\n    );\n  }\n\n  const scheduleConfigSync = useCallback(\n    throttle((nextValue: Array<BlockElement>) => {\n      setEditorValue(nextValue);\n      const nextElements = convertEditorValueToRichTextElements(nextValue);\n\n      actions.runChange(() => {\n        const newRichTextElement: RichTextComponentConfig = {\n          ...richTextConfig,\n          elements: {\n            ...richTextConfig.elements,\n            [editorContext.contextParams.locale]: nextElements,\n          },\n        };\n\n        form.change(path, newRichTextElement);\n        previousRichTextComponentConfig.current = newRichTextElement;\n\n        if (editor.selection) {\n          const nextFocusedFields = getFocusedFieldsFromSlateSelection(\n            editor,\n            path,\n            contextParams.locale\n          );\n\n          return nextFocusedFields;\n        }\n      });\n    }, RICH_TEXT_CONFIG_SYNC_THROTTLE_TIMEOUT),\n    [isConfigChanged, editorContext.contextParams.locale]\n  );\n\n  const scheduleFocusedFieldsChange = useCallback(\n    // Slate internally throttles the invocation of DOMSelectionChange for performance reasons.\n    // We also throttle update of our focused fields state for the same reason.\n    // This gives us a good balance between perf and showing updated fields within the sidebar.\n    throttle((focusedFields: Parameters<typeof setFocussedField>[0]) => {\n      setFocussedField(focusedFields);\n    }, RICH_TEXT_FOCUSED_FIELDS_SYNC_THROTTLE_TIMEOUT),\n    [setFocussedField]\n  );\n\n  function handleEditableChange(value: Array<Descendant>): void {\n    if (!isEnabled) {\n      return;\n    }\n\n    // Editor's value can be changed from outside ex. sidebar or history undo/redo. If the last reason for change\n    // was \"external\", we skip this change. In case we would like to start typing immediately after undo/redo we\n    // set last change reason to `text-input`.\n    if (\n      lastChangeReason.current === \"external\" ||\n      lastChangeReason.current === \"paste\"\n    ) {\n      lastChangeReason.current = \"text-input\";\n      return;\n    }\n\n    const isValueSame = deepCompare(value, editorValue);\n\n    // Slate runs `onChange` callback on any change, even when the text haven't changed.\n    // If value haven't changed, it must be a selection change.\n    if (isValueSame) {\n      const nextFocusedFields = getFocusedFieldsFromSlateSelection(\n        editor,\n        path,\n        contextParams.locale\n      );\n\n      if (nextFocusedFields) {\n        scheduleFocusedFieldsChange(nextFocusedFields);\n      }\n\n      return;\n    }\n\n    lastChangeReason.current = \"text-input\";\n    scheduleConfigSync(value as Array<BlockElement>);\n  }\n\n  function handleEditableFocus(): void {\n    if (!isEnabled) {\n      return;\n    }\n\n    lastChangeReason.current = \"text-input\";\n\n    // When value for current locale is empty we present the value from fallback.\n    // If user focuses editable element, we present the value of fallback unless it's also empty.\n    if (!localizedRichTextElements) {\n      let nextSlateValue = editor.children;\n      let nextRichTextComponentConfig: RichTextComponentConfig;\n\n      if (fallbackRichTextElements) {\n        nextRichTextComponentConfig = richTextConfig;\n        const fallbackFirstTextPart =\n          fallbackRichTextElements[0].elements[0].elements[0];\n\n        // Keep only one line element with single empty rich text\n        nextRichTextComponentConfig.elements[contextParams.locale] = [\n          {\n            ...fallbackRichTextElements[0],\n            elements: [\n              {\n                ...fallbackRichTextElements[0].elements[0],\n                elements: [\n                  {\n                    ...fallbackFirstTextPart,\n                    value: \"\",\n                  } as RichTextPartComponentConfig,\n                ],\n              },\n            ],\n          },\n        ];\n\n        nextSlateValue = convertRichTextElementsToEditorValue(\n          nextRichTextComponentConfig.elements[contextParams.locale]\n        );\n\n        editor.children = nextSlateValue;\n\n        Transforms.select(editor, {\n          anchor: Editor.start(editor, []),\n          focus: Editor.start(editor, []),\n        });\n\n        form.change(path, nextRichTextComponentConfig);\n      } else {\n        // If current and fallback value is missing we have:\n        // - empty Slate value\n        // - empty config within component-collection-localised\n        // We will build next $richText component config based on current Slate value\n        nextRichTextComponentConfig = richTextConfig;\n        nextRichTextComponentConfig.elements[contextParams.locale] =\n          convertEditorValueToRichTextElements(\n            editor.children as Array<BlockElement>\n          );\n        form.change(path, nextRichTextComponentConfig);\n      }\n\n      previousRichTextComponentConfig.current = nextRichTextComponentConfig;\n\n      if (editor.selection) {\n        const nextFocusedFields = getFocusedRichTextPartsConfigPaths(\n          editor\n        ).map((richTextPartPath) =>\n          getAbsoluteRichTextPartPath(\n            richTextPartPath,\n            path,\n            contextParams.locale\n          )\n        );\n\n        setFocussedField(nextFocusedFields);\n      }\n    }\n\n    if (isDecorationActive) {\n      const root = ReactEditor.findDocumentOrShadowRoot(editor);\n      const slateStringElements = root.querySelectorAll(\"[data-slate-string]\");\n      slateStringElements.forEach((element) => {\n        element.replaceChildren(document.createTextNode(element.textContent!));\n      });\n    }\n  }\n\n  useEffect(() => {\n    function saveLatestSelection() {\n      const root = ReactEditor.findDocumentOrShadowRoot(editor);\n      const selection = (root as Document).getSelection();\n\n      if (selection && selection.type === \"Range\") {\n        currentSelectionRef.current = ReactEditor.toSlateRange(\n          editor,\n          selection,\n          { exactMatch: false, suppressThrow: true }\n        );\n      } else {\n        currentSelectionRef.current = null;\n      }\n    }\n\n    const throttledSaveLatestSelection = throttle(saveLatestSelection, 100);\n\n    if (isEnabled) {\n      window.document.addEventListener(\n        \"selectionchange\",\n        throttledSaveLatestSelection\n      );\n\n      return () => {\n        window.document.removeEventListener(\n          \"selectionchange\",\n          throttledSaveLatestSelection\n        );\n      };\n    }\n  }, [editor, isEnabled]);\n\n  function handleEditableBlur(): void {\n    lastChangeReason.current = \"external\";\n    setIsDecorationActive(true);\n  }\n\n  // When copying content from content editable, Slate will copy HTML content of selected nodes\n  // and this is not what we want. Instead we set clipboard data to contain selected content\n  // in form of rich text editable component config.\n  function handleEditableCopy(event: React.ClipboardEvent) {\n    const selectedRichTextComponentConfig = getRichTextComponentConfigFragment(\n      richTextConfig,\n      editorContext\n    );\n\n    event.clipboardData.setData(\n      \"text/x-shopstory\",\n      JSON.stringify(selectedRichTextComponentConfig)\n    );\n  }\n\n  function handleEditablePaste(event: React.ClipboardEvent) {\n    const selectedRichTextComponentConfigClipboardData =\n      event.clipboardData.getData(\"text/x-shopstory\");\n\n    if (selectedRichTextComponentConfigClipboardData) {\n      const selectedRichTextComponentConfig: RichTextComponentConfig =\n        JSON.parse(selectedRichTextComponentConfigClipboardData);\n\n      // Preventing the default action will also prevent Slate from handling this event on his own.\n      event.preventDefault();\n\n      const nextSlateValue = convertRichTextElementsToEditorValue(\n        duplicateConfig(selectedRichTextComponentConfig, editorContext)\n          .elements[contextParams.locale]\n      );\n\n      const temporaryEditor = createTemporaryEditor(editor);\n      Editor.insertFragment(temporaryEditor, nextSlateValue);\n      const nextElements = convertEditorValueToRichTextElements(\n        temporaryEditor.children as Array<BlockElement>\n      );\n\n      actions.runChange(() => {\n        form.change(richTextElementsConfigPath, nextElements);\n\n        const nextFocusedFields = getFocusedFieldsFromSlateSelection(\n          temporaryEditor,\n          path,\n          contextParams.locale\n        );\n\n        return nextFocusedFields;\n      });\n\n      lastChangeReason.current = \"paste\";\n    } else if (\n      // Slate only handles pasting if the clipboardData contains text/plain type.\n      // When copying text from the Contentful's rich text editor, the clipboardData contains\n      // more than one type, so we have to handle this case manually.\n      event.clipboardData.types.length > 1 &&\n      event.clipboardData.types.some((type) => type === \"text/plain\")\n    ) {\n      Editor.insertText(editor, event.clipboardData.getData(\"text/plain\"));\n      event.preventDefault();\n    }\n  }\n\n  const contentEditableClassName = useMemo(() => {\n    const responsiveAlignmentStyles = mapResponsiveAlignmentToStyles(align, {\n      devices: editorContext.devices,\n      resop,\n    });\n\n    const isFallbackValueShown =\n      localizedRichTextElements === undefined &&\n      fallbackRichTextElements !== undefined;\n\n    // When we make a selection of text within editable container and then blur\n    // sometimes the browser selection changes and shows incorrectly selected chunks.\n    const getStyles = stitches.css({\n      display: \"flex\",\n      ...responsiveAlignmentStyles,\n      cursor: !isEnabled ? \"inherit\" : \"text\",\n      \"& *\": {\n        pointerEvents: isEnabled ? \"auto\" : \"none\",\n        userSelect: isEnabled ? \"auto\" : \"none\",\n      },\n      \"& *::selection\": {\n        backgroundColor: \"#b4d5fe\",\n      },\n      ...(isDecorationActive && {\n        \"& *::selection\": {\n          backgroundColor: \"transparent\",\n        },\n        \"& *[data-easyblocks-rich-text-selection]\": {\n          backgroundColor: \"#b4d5fe\",\n        },\n      }),\n      ...(isFallbackValueShown && {\n        opacity: 0.5,\n      }),\n      // Remove any text decoration from slate nodes that are elements. We only need text decoration on text elements.\n      \"[data-slate-node]\": {\n        textDecoration: \"none\",\n      },\n    });\n\n    return getStyles().className;\n  }, [\n    align,\n    isDecorationActive,\n    localizedRichTextElements,\n    fallbackRichTextElements,\n    isEnabled,\n  ]);\n\n  return (\n    <Slate editor={editor} value={editorValue} onChange={handleEditableChange}>\n      <div>\n        {/* this wrapper div prevents from Chrome bug where \"pointer-events: none\" on contenteditable is ignored*/}\n        <Editable\n          className={contentEditableClassName}\n          placeholder=\"Here goes text content\"\n          renderElement={renderElement}\n          renderLeaf={renderLeaf}\n          renderPlaceholder={renderPlaceholder}\n          decorate={decorate}\n          onFocus={handleEditableFocus}\n          onBlur={handleEditableBlur}\n          onCopy={handleEditableCopy}\n          onPaste={handleEditablePaste}\n          onMouseDown={(event) => {\n            if (isEnabled) {\n              event.stopPropagation();\n              return;\n            }\n\n            if (event.detail === 2) {\n              event.preventDefault();\n\n              flushSync(() => {\n                setIsEnabled(true);\n              });\n\n              ReactEditor.focus(editor);\n\n              if (isEditorValueEmpty(editor.children as Array<BlockElement>)) {\n                return;\n              }\n\n              const editorSelectionRange = {\n                anchor: Editor.start(editor, []),\n                focus: Editor.end(editor, []),\n              };\n\n              Transforms.setSelection(editor, editorSelectionRange);\n              const editorSelectionDOMRange = ReactEditor.toDOMRange(\n                editor,\n                editorSelectionRange\n              );\n\n              window\n                .getSelection()\n                ?.setBaseAndExtent(\n                  editorSelectionDOMRange.startContainer,\n                  editorSelectionDOMRange.startOffset,\n                  editorSelectionDOMRange.endContainer,\n                  editorSelectionDOMRange.endOffset\n                );\n            }\n          }}\n          readOnly={!isEnabled}\n        />\n      </div>\n    </Slate>\n  );\n}\n\nexport { RichTextEditor };\nexport type { RichTextProps };\n\nfunction isEditorValueEmpty(editorValue: Array<BlockElement>) {\n  return (\n    editorValue.length === 1 &&\n    editorValue[0].children.length === 1 &&\n    editorValue[0].children[0].children.length === 1 &&\n    Text.isText(editorValue[0].children[0].children[0]) &&\n    editorValue[0].children[0].children[0].text === \"\"\n  );\n}\n\nfunction isConfigEqual(newConfig: any, oldConfig: any) {\n  return deepCompare(newConfig, oldConfig);\n}\n\nfunction mapResponsiveAlignmentToStyles(\n  align: ResponsiveValue<Alignment>,\n  { devices, resop }: { devices: Devices; resop: any }\n) {\n  function mapAlignmentToFlexAlignment(align: Alignment) {\n    if (align === \"center\") {\n      return \"center\";\n    }\n\n    if (align === \"right\") {\n      return \"flex-end\";\n    }\n\n    return \"flex-start\";\n  }\n\n  const responsiveStyles = resop(\n    {\n      align: responsiveValueFill(align, devices, getDevicesWidths(devices)),\n    },\n    (values: any) => {\n      return {\n        justifyContent: mapAlignmentToFlexAlignment(values.align),\n        textAlign: values.align,\n      };\n    },\n    devices\n  );\n\n  const compiledStyles = compileBox(responsiveStyles, devices);\n\n  return getBoxStyles(compiledStyles, devices);\n}\n\nfunction createTextSelectionDecorator(editor: Editor) {\n  return ([node, path]: NodeEntry) => {\n    const decorations: Array<Range> = [];\n\n    if (\n      Text.isText(node) &&\n      editor.selection !== null &&\n      node.TextWrapper.length > 0 &&\n      Range.isCollapsed(editor.selection)\n    ) {\n      const textRange = Editor.range(editor, path);\n      const intersection = Range.intersection(editor.selection, textRange);\n\n      if (intersection !== null) {\n        const range = {\n          isHighlighted: true,\n          highlightType: \"textWrapper\",\n          ...textRange,\n        };\n\n        decorations.push(range);\n      }\n    }\n\n    return decorations;\n  };\n}\n\nfunction splitStringNodes(editor: Editor, selection: BaseRange) {\n  const nodes = Editor.nodes(editor, {\n    at: selection,\n    match: Text.isText,\n  });\n\n  const domNodes = Array.from(nodes).map(([node]) => {\n    const domNode = ReactEditor.toDOMNode(editor, node);\n\n    return domNode;\n  });\n\n  if (domNodes.length === 1) {\n    const slateString = domNodes[0].querySelector(\"[data-slate-string]\");\n    const textContent = slateString!.textContent!;\n    const newChild = document.createDocumentFragment();\n\n    // Selection made within whole text node\n    if (\n      textContent.length === selection.focus.offset - selection.anchor.offset ||\n      textContent.length === selection.anchor.offset - selection.focus.offset\n    ) {\n      const selectedTextNode = document.createElement(\"span\");\n      selectedTextNode.textContent = textContent;\n      selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\n      newChild.appendChild(selectedTextNode);\n      slateString!.replaceChildren(newChild);\n    } else {\n      const selectedTextNode = document.createElement(\"span\");\n      selectedTextNode.textContent = textContent.slice(\n        selection.anchor.offset,\n        selection.focus.offset\n      );\n      selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\n      newChild.appendChild(\n        document.createTextNode(textContent.slice(0, selection.anchor.offset))\n      );\n      newChild.appendChild(selectedTextNode);\n      newChild.appendChild(\n        document.createTextNode(textContent.slice(selection.focus.offset))\n      );\n      slateString!.replaceChildren(newChild);\n    }\n\n    return;\n  }\n\n  domNodes.forEach((node, index) => {\n    const slateString = node.querySelector(\"[data-slate-string]\");\n\n    if (slateString) {\n      const textContent = slateString.textContent!;\n      const newChild = document.createDocumentFragment();\n\n      if (index === 0) {\n        newChild.appendChild(\n          document.createTextNode(\n            slateString.textContent!.slice(0, selection.anchor.offset)\n          )\n        );\n        const selectedTextNode = document.createElement(\"span\");\n        selectedTextNode.textContent = textContent.slice(\n          selection.anchor.offset\n        );\n        selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\n        newChild.appendChild(selectedTextNode);\n\n        slateString.replaceChildren(newChild);\n      } else if (index === domNodes.length - 1) {\n        const selectedTextNode = document.createElement(\"span\");\n        selectedTextNode.textContent = textContent.slice(\n          0,\n          selection.focus.offset\n        );\n        selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\n        newChild.appendChild(selectedTextNode);\n        newChild.appendChild(\n          document.createTextNode(textContent.slice(selection.focus.offset))\n        );\n        slateString.replaceChildren(newChild);\n      } else {\n        const selectedTextNode = document.createElement(\"span\");\n        selectedTextNode.textContent = textContent;\n        selectedTextNode.dataset.easyblocksRichTextSelection = \"true\";\n        newChild.appendChild(selectedTextNode);\n        slateString.replaceChildren(newChild);\n      }\n    }\n  });\n}\n\nfunction unwrapStringNodesContent(editor: Editor) {\n  const root = ReactEditor.findDocumentOrShadowRoot(editor);\n  const slateStringElements = root.querySelectorAll(\"[data-slate-string]\");\n  slateStringElements.forEach((element) => {\n    element.replaceChildren(document.createTextNode(element.textContent!));\n  });\n}\n"],"names":["editorContext","setFocussedField","__easyblocks","runtime","devices","align","richTextConfig","Transforms","useLayoutEffect","splitStringNodes","useEffect","editor","form","payload","currentSelectionRef","elements","window","element","__compiled","stitches","leaf","TextPart","value","Text","TextWrapper","path","passedProps","children","style","top","left","nextRichTextComponentConfig","focus","slateStringElements","exactMatch","suppressThrow","event","Editor","resop","display","cursor","pointerEvents","userSelect","backgroundColor","opacity","textDecoration","onChange","className","placeholder","renderElement","renderLeaf","renderPlaceholder","decorate","onFocus","onBlur","onCopy","onPaste","flushSync","ReactEditor","readOnly","justifyContent","isHighlighted","highlightType","decorations","at","selectedTextNode","newChild","slateString","domNodes"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuEA;;AACUA;AAAc;;;;;;;AAQpBC;AACF;;AAGEC;;AAEEC;;;AAA4BC;AAAQ;;AAEtCC;AACF;;AAOA;;AAKA;AAMA;;AAKA;;AAIA;AACA;;AAEE;AACA;AACAC;;AAGF;;AAEA;AACF;AACA;AACA;;;AAGE;AACF;AACA;AACA;AACA;AACA;AACE;;AAIA;AACF;AACA;;AAEE;AACA;;AAOA;AACE;;AAEA;;AAGA;AAEA;AACA;AACA;;;AAIA;AACE;AAKA;;AAEA;AACE;AACA;AACA;;AAEEC;;AAEAA;AACF;AACEA;AACF;AACF;AACF;AACF;AAEAC;AACE;AAKEC;AAEA;;;AAGF;;AAGF;AAIAD;AACE;AACA;;;AAGA;AACF;AAEAE;AACE;;;;AAKA;AACA;AACA;;AAEE;AACE;;;AAGF;AAEA;AACE;AACF;;AAGEH;AAEA;;AAIA;AACA;AACA;AACE;AACA;AACAI;AAGAC;AACF;AACF;;AAKJF;AACE;;;AAGA;AACF;AAEAA;;AAEI;AACE;AACF;AAEA;;AACUG;;;AACAb;AAAc;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAOE;AACF;AAEAc;;AAGE;AACE;AACAC;;AAEE;AAEF;;AAGFH;;AAYA;AACF;AACF;AACF;AAEAI;AAEA;AACEA;;AAEJ;AAEA;AACA;;;;;AAKEC;AACkB;AAClB;;AAOE;AACA;AACE;AACE;AAKF;AAEA;AACF;AAEA;AACF;;AAGE;AACE;AACE;;AAEA;;AAEA;AACF;AACF;AACE;AACE;AACF;AACE;AACF;AACF;AACF;;AAGE;AACF;AAEA;AAEIC;AACAd;AACAe;;;;AAMA;AAKN;AAEA;;;;;AAE4CC;AAAsB;AAChE;AACE;AACF;;AAGEC;;AAEA;AACF;;AAGE;AACA;AACE;AACF;AAEA;AACF;AAEA;AAEIC;AACAC;AAEIL;AACAd;AACAe;;AAIJK;;AAIMC;;AAEAC;;AAGA;AAAE;AAGP;AAIL;AACF;;AAEA;AACA;;;;AACyCC;AAAiC;AACxE;AAGIC;;AAEEC;AACAC;AACF;AAAE;AAKR;AAEA;;AAGI;;AAGE;AACE;AACAf;;AAEE;AACF;;AAGFH;;;;AAUE;AACF;AACF;AACF;;AAKA;AACA;AACA;;;AAGA;;;AAME;AACF;;AAEA;AACA;AACA;;;AAME;AACF;AAEA;;AAEA;AACA;AACA;;AAOE;;AAEA;AAEA;AACF;;;AAIF;;;AAII;AACF;;;AAIA;AACA;;AAEE;AACA;AAEA;AACEmB;AACA;;AAGA;;;AAIIhB;;AAGIA;AAEI;AACAO;;;AAKV;;;AASFf;;AAEEyB;AACF;AAEApB;AACF;AACE;AACA;AACA;AACA;AACAmB;AACAA;AAIAnB;AACF;;;;;AAgBA;AACF;AAEA;AACE;AACA;AACAqB;;AAEA;AACF;AACF;AAEAvB;;AAEI;AACA;AAEA;;AAIMwB;AAAmBC;AAAoB;AAE7C;;AAEA;AACF;AAEA;AAEA;;AAME;;;AAMF;AACF;;;;AAKA;;AAEA;AACA;AACA;;AAEE;AAKAC;AAIF;;;AAME;AACE;;AAGA;;AAGA;AAKA;AACAC;AACA;;AAKEzB;;AAQA;AACF;;AAGF;AACE;AACA;AACA;;AAIAyB;;AAEF;AACF;AAEA;AACE;;AAEEC;AACF;;;AAMA;AACA;AACA;AACEC;AACA;AACAC;AACA;AACEC;AACAC;;AAEF;AACEC;;AAEF;AACE;AACEA;;AAEF;AACEA;AACF;AACF;AACA;AACEC;AACF;AACA;AACA;AACEC;AACF;AACF;AAEA;AACF;AAQA;AACSlC;AAAgBW;AAAoBwB;;AAIrCC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEE;;AAEE;AACF;AAEA;;AAGEC;;AAEA;AAEAC;AAEA;AACE;AACF;AAEA;;AAEE1B;;AAGFzB;;;AAcF;;AAEFoD;;AAKV;AAKA;AACE;AAOF;AAEA;AACE;AACF;AAEA;;;AAEarB;AAAwC;;;AAI/C;AACF;;AAGE;AACF;AAEA;AACF;;;;;AAQMsB;;;;AAON;AAEA;AACF;AAEA;AACE;AAAoC;;AAGlC;;;;AAUI;AACEC;AACAC;;;AAIFC;AACF;AACF;AAEA;;AAEJ;AAEA;AACE;AACEC;;AAEF;AAEA;AAAmD;;AAGjD;AACF;AAEA;;AAEE;AACA;;AAEA;AACA;AAIE;;AAEAC;AACAC;AACAC;AACF;AACE;AACAF;AAIAA;;AAIAC;AACAA;AAGAC;AACF;AAEA;AACF;AAEAC;AACE;AAEA;AACE;AACA;;;AAQE;AACAH;AAGAA;AACAC;AAEAC;;AAEA;AACAF;AAIAA;AACAC;AACAA;AAGAC;AACF;AACE;;AAEAF;AACAC;AACAC;AACF;AACF;AACF;AACF;AAEA;AACE;AACA;AACAlC;;AAEA;AACF;;"}