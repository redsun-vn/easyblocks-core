{"version":3,"file":"parsePath.cjs","sources":["../../../src/compiler/parsePath.ts"],"sourcesContent":["import { dotNotationGet } from \"@/utils\";\r\n/**\r\n * When selecting text within $richText, we keep information about which text parts are selected\r\n * within focused fields. If the text part is partially selected, we add information about the selection.\r\n * This selection has format: \".{textPartCharacterSelectionStartIndex,textPartCharacterSelectionEndIndex}\".\r\n * We often want to query related to selection text part component config and to do that correctly we need to\r\n * strip information about selection.\r\n */\r\nfunction stripRichTextPartSelection(value: string): string {\r\n  return value.replace(/\\.\\{\\d+,\\d+\\}$/g, \"\");\r\n}\r\nexport { stripRichTextPartSelection };\r\n\r\nexport type ParentPathInfo = {\r\n  templateId: string;\r\n  fieldName: string;\r\n  path: string;\r\n};\r\n\r\nexport type PathInfo = {\r\n  templateId: string;\r\n  /**\r\n   * Relative field name. `undefined` when path IS a component.\r\n   */\r\n  fieldName?: string;\r\n  /**\r\n   * If component is in the collection, then it is its index.\r\n   */\r\n  index?: number;\r\n  parent?: ParentPathInfo;\r\n};\r\n\r\nexport function parsePath(path: string, form: any): PathInfo {\r\n  const values = form.values;\r\n  const pathSplit =\r\n    path === \"\" ? [] : stripRichTextPartSelection(path).split(\".\");\r\n\r\n  let pathInfo:\r\n    | {\r\n      templateId: string;\r\n      index?: number;\r\n      fieldName?: string;\r\n      parent?: ParentPathInfo;\r\n    }\r\n    | undefined = undefined;\r\n\r\n  // We're going from current path down the path to find current template and parent template\r\n  for (let i = pathSplit.length; i >= 0; i--) {\r\n    const testedPath = pathSplit.slice(0, i).join(\".\");\r\n    const value = dotNotationGet(values, testedPath);\r\n\r\n    if (typeof value === \"object\" && typeof value._component === \"string\") {\r\n      if (pathInfo === undefined) {\r\n        pathInfo = {\r\n          templateId: value._component,\r\n        };\r\n\r\n        // fieldName\r\n        const fieldPath = pathSplit.slice(i);\r\n        if (fieldPath.length > 0) {\r\n          pathInfo.fieldName = fieldPath.join(\".\");\r\n        }\r\n\r\n        const potentialIndex = parseInt(pathSplit[i - 1]);\r\n        if (!isNaN(potentialIndex)) {\r\n          pathInfo.index = potentialIndex;\r\n        }\r\n      } else {\r\n        pathInfo.parent = {\r\n          templateId: value._component,\r\n          fieldName: pathSplit[i],\r\n          path: testedPath,\r\n        };\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!pathInfo) {\r\n    throw new Error(`incorrect path: ${path}`);\r\n  }\r\n\r\n  return pathInfo;\r\n}\r\n\r\nexport function findPathOfFirstAncestorOfType(\r\n  path: string,\r\n  templateId: string,\r\n  form: any\r\n): string {\r\n  while (true) {\r\n    const parseResult = parsePath(path, form);\r\n\r\n    if (!parseResult.parent) {\r\n      throw new Error(`couldn't find ancestor of type ${templateId}`);\r\n    }\r\n\r\n    if (parseResult.parent.templateId === templateId) {\r\n      return parseResult.parent.path;\r\n    }\r\n\r\n    path = parseResult.parent.path;\r\n  }\r\n}\r\n"],"names":["stripRichTextPartSelection","value","replace","parsePath","path","form","values","pathSplit","split","pathInfo","undefined","i","length","testedPath","slice","join","dotNotationGet","_component","templateId","fieldPath","fieldName","potentialIndex","parseInt","isNaN","index","parent","Error","findPathOfFirstAncestorOfType","parseResult"],"mappings":"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"}