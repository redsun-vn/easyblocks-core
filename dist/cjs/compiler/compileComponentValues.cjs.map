{"version":3,"file":"compileComponentValues.cjs","sources":["../../../src/compiler/compileComponentValues.ts"],"sourcesContent":["/**\r\n * This compilation function doesn't take schema. It means that it assumes couple of things:\r\n * 1. That input is NoCodeComponentEntry or 1-item array of. NoCodeComponentEntry. Basically it's a single component.\r\n * 2. Return format\r\n */\r\n\r\nimport { CompilationCache } from \"./CompilationCache\";\r\nimport { compileFromSchema } from \"./compileFromSchema\";\r\nimport { isSchemaPropComponentOrComponentCollection } from \"./schema\";\r\nimport { CompilationContextType, InternalComponentDefinition } from \"./types\";\r\n\r\nexport function compileComponentValues(\r\n  inputValues: Record<string, any>,\r\n  componentDefinition: InternalComponentDefinition,\r\n  compilationContext: CompilationContextType,\r\n  cache: CompilationCache\r\n) {\r\n  const values: Record<string, any> = {};\r\n\r\n  componentDefinition!.schema.forEach((schemaProp) => {\r\n    if (!isSchemaPropComponentOrComponentCollection(schemaProp)) {\r\n      values[schemaProp.prop] = compileFromSchema(\r\n        inputValues[schemaProp.prop],\r\n        schemaProp,\r\n        compilationContext,\r\n        cache\r\n      );\r\n    }\r\n  });\r\n\r\n  return values;\r\n}\r\n"],"names":["compileComponentValues","inputValues","componentDefinition","compilationContext","cache","values","schema","forEach","schemaProp","isSchemaPropComponentOrComponentCollection","prop","compileFromSchema"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAOO,SAASA,sBAAsBA,CACpCC,WAAgC,EAChCC,mBAAgD,EAChDC,kBAA0C,EAC1CC,KAAuB,EACvB;EACA,MAAMC,MAA2B,GAAG,EAAE,CAAA;AAEtCH,EAAAA,mBAAmB,CAAEI,MAAM,CAACC,OAAO,CAAEC,UAAU,IAAK;AAClD,IAAA,IAAI,CAACC,gDAA0C,CAACD,UAAU,CAAC,EAAE;MAC3DH,MAAM,CAACG,UAAU,CAACE,IAAI,CAAC,GAAGC,mCAAiB,CACzCV,WAAW,CAACO,UAAU,CAACE,IAAI,CAAC,EAC5BF,UAAU,EACVL,kBAAkB,EAClBC,KACF,CAAC,CAAA;AACH,KAAA;AACF,GAAC,CAAC,CAAA;AAEF,EAAA,OAAOC,MAAM,CAAA;AACf;;;;"}